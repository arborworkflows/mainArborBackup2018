{"_id": "577b6a8054cdbf3c14cc4612", "_modelType": "item", "baseParentId": "577b6a6154cdbf3c14cc460c", "baseParentType": "collection", "created": "2016-07-05T08:06:24.226000+00:00", "creatorId": "5761b37954cdbf3c14cc45bc", "description": "", "folderId": "577b6a6254cdbf3c14cc460d", "meta": {"analysis": {"inputs": [{"format": "r.dataframe", "name": "table", "type": "table"}, {"format": "r.apetree", "name": "tree", "type": "tree"}, {"domain": {"format": "column.names", "input": "table"}, "format": "text", "name": "column", "type": "string"}, {"default": "[object Object]", "domain": ["lambda", "K"], "format": "text", "name": "method", "type": "string"}], "mode": "r", "name": "Phylogenetic signal", "outputs": [{"format": "r.dataframe", "name": "result", "type": "table"}], "script": "#data(anolis); tree <- anolis$phy; table <- anolis$dat; column <- \"SVL\"; method <- \"lambda\"; discreteModelType=\"ER\"\nlibrary(devtools)\n#options(repos=\"http://cran.cnr.Berkeley.edu\")\n#install_github(\"arborworkflows/aRbor\")\n# measure phylogenetic signal\nrequire(aRbor)\n\n# Names and data match - so data integrator might be needed at this step\n# (in general) but is not needed in this case.\n\ntd <- make.treedata(tree, table)\ntd <- select(td, which(colnames(td$dat)==column))\nphy <- td$phy\ndat <- td$dat\n\ncharType <- aRbor:::detectCharacterType(dat[[1]], cutoff=0.2)\n\nif(charType==\"discrete\"){\n  result <- physigArbor(td, charType=charType, signalTest=\"pagelLambda\")\n}\nif(charType==\"continuous\"){\n  if(method==\"lambda\") result <- physigArbor(td, charType=charType, signalTest=\"pagelLambda\")\n  if(method==\"K\") result <- physigArbor(td, charType=charType, signalTest=\"Blomberg\")\n}\n\nresult <- t(as.data.frame(unlist(result)))\nrownames(result) <- NULL\nresult"}}, "name": "Phylogenetic signal", "size": 0, "updated": "2016-07-05T08:06:24.350000+00:00"}