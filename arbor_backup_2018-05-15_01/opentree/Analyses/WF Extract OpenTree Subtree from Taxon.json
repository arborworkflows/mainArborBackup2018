{"connections": [{"input": "tree", "input_step": "Assign Tree Branch Branch Lengths If Missing", "output": "subtree", "output_step": "OpenTree Return Subtree from Taxon"}, {"name": "outtree", "output": "outtree", "output_step": "Assign Tree Branch Branch Lengths If Missing"}, {"input": "taxonName", "input_step": "OpenTree Return Subtree from Taxon", "name": "Taxon Root of Subtree"}, {"name": "Debug String", "output": "outstring", "output_step": "OpenTree Return Subtree from Taxon"}], "description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "Taxon Root of Subtree", "name": "Taxon Root of Subtree", "type": "string", "x": 52, "y": 256}], "mode": "workflow", "name": "WF Extract OpenTree Subtree from Taxon", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree", "x": 893, "y": 220}, {"format": "text", "id": "Debug String", "name": "Debug String", "type": "string", "x": 819, "y": 405}], "steps": [{"girderId": "590b4b1e54cdbf7a5dff8634", "modified": "2017-05-04T15:39:11.050000+00:00", "name": "Assign Tree Branch Branch Lengths If Missing", "task": {"description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}], "mode": "python", "name": "Assign Tree Branch Branch Lengths If Missing", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree"}], "script": "nodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \nouttree = tree\nassignEdgeWeightsIfMissing(outtree)\n"}, "visualization": false, "x": 593, "y": 220}, {"girderId": "590cc43c54cdbf7a5dff8698", "modified": "2017-05-05T18:29:06.614990+00:00", "name": "OpenTree Return Subtree from Taxon", "task": {"description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "taxonName", "name": "Taxon Root of Subtree", "type": "string"}], "mode": "python", "name": "OpenTree Return Subtree from Taxon", "outputs": [{"description": "returned OpenTree subtree", "format": "newick", "id": "subtree", "name": "OpenTree subtree", "type": "tree"}, {"format": "text", "id": "outstring", "name": "Debug String", "type": "string"}], "script": "#\n# Return an OpenTree Subtree given a starting taxon\n#\n# description: this analysis starts with a taxon name, resolves to an OTT ID, then\n# pulls the subtree below this taxon\n# \n# input: taxon - (string) taxon name to serve as the root of the returned tree\n# output: subtree -  subtree returned by OpenTree\n#\n\nimport requests\nimport json\n\noutrows = []\noutstring = ''\n\n\n# curl -POST https://api.opentreeoflife.org/v3/tnrs/match_names -H \"content-type:application/json\" \n# -d '{\"names\":[\"Aster\",\"Symphyotrichum\",\"Barnadesia\"]}'\n\n# pack the names into a payload and perform the OpenTree lookup using v3, which has same syntax as v2.\npayload = json.dumps({'names': [taxonName]})\noutstring = outstring+'payload: '+payload\nheaders = {'content-type':'application/json'}\nresp = requests.post('https://api.opentreeoflife.org/v2/tnrs/match_names',data=payload,headers=headers)\noutstring = outstring+' \\nresponse: '+resp.text\n\ntry:\n    returnedrecs = resp.json()['results']\n    thisresult = returnedrecs[0]\n    candidate = thisresult['matches'][0]\n    ottName = candidate['ot:ottTaxonName']\n    ottId = candidate['ot:ottId']\n    outstring += '\\n returned name: '+ottName+' ottId: '+str(ottId)\nexcept:\n    outstring = outstring+'\\nerror in OpenTree TNRS lookup. No result returned'\n\n\n\n# now return the subtree from a given OTT ID\n# curl -X POST https://api.opentreeoflife.org/v3/tree_of_life/subtree -H \"content-type:application/json\" -d '{\"node_id\":\"ott803675\"}'\n\n# build an OTL query to return the matching ottId we want to use to request taxa \nottIdNameString = 'ott'+str(ottId)\npayload = json.dumps({'node_id' : ottIdNameString})\nheaders = {'content-type':'application/json'}\nquerystring = 'https://api.opentreeoflife.org/v3/tree_of_life/subtree'\nrespTree = requests.post(querystring,data=payload,headers=headers)\noutstring = outstring+' \\n tree response: \\n'+respTree.text\ntry:\n    respTreeJson = respTree.json()\n    subtree = respTreeJson['newick']\n    # add an extra set of parenthesis around the newick tree returned to fit the original definition of Newick format\n    #subtree = '('+subtree[:-1]+');'\n    outstring += '\\n extracted subtree: '+subtree\n    #subtree = ';'\nexcept:\n    subtree = ';'\n    outstring = outstring+'\\nerror returning OpenTree Subtree'\n  \n    \n"}, "visualization": false, "x": 339, "y": 261}]}