{"_id": "590fc01754cdbf37f06511d7", "_modelType": "item", "baseParentId": "58fad7c954cdbf552d799223", "baseParentType": "collection", "created": "2017-05-08T00:47:19.058000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "58fad7c954cdbf552d799225", "meta": {"analysis": {"connections": [{"input": "tree", "input_step": "Prune Tree On Levels Below Root", "output": "subtree", "output_step": "OpenTree Return Subtree from Taxon"}, {"input": "taxonName", "input_step": "OpenTree Return Subtree from Taxon", "name": "Taxon Root of Subtree"}, {"input": "numLevels", "input_step": "Prune Tree On Levels Below Root", "name": "number of levels to pass through"}, {"input": "tree", "input_step": "Tip Names from Nested Tree", "output": "prunedTree", "output_step": "Prune Tree On Levels Below Root"}, {"input": "table", "input_step": "Convert Table of OpenTree Names to Scientific Names", "output": "nametable", "output_step": "Tip Names from Nested Tree"}, {"input": "table", "input_step": "Table Pass Single Scientific Names Only", "output": "outtable", "output_step": "Convert Table of OpenTree Names to Scientific Names"}, {"name": "outtable", "output": "outtable", "output_step": "Table Pass Single Scientific Names Only"}], "description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "Taxon Root of Subtree", "name": "Taxon Root of Subtree", "type": "string", "x": 18, "y": 40.99999237060547}, {"default": {"data": "2", "format": "text", "type": "string"}, "description": "the number of levels to pass through to the output tree; levels below are pruned", "format": "number", "id": "number of levels to pass through", "name": "number of levels to pass through", "type": "number", "x": 34, "y": 340}], "mode": "workflow", "name": "WF curate family names for clade analysis", "outputs": [{"description": "filtered output table with rows suitable for use with tip matching algortihms", "format": "rows", "id": "outtable", "name": "outtable", "type": "table", "x": 1349, "y": 202}], "steps": [{"girderId": "590cc43c54cdbf7a5dff8698", "modified": "2017-05-05T18:29:06.614000+00:00", "name": "OpenTree Return Subtree from Taxon", "task": {"description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "taxonName", "name": "Taxon Root of Subtree", "type": "string"}], "mode": "python", "name": "OpenTree Return Subtree from Taxon", "outputs": [{"description": "returned OpenTree subtree", "format": "newick", "id": "subtree", "name": "OpenTree subtree", "type": "tree"}, {"format": "text", "id": "outstring", "name": "Debug String", "type": "string"}], "script": "#\n# Return an OpenTree Subtree given a starting taxon\n#\n# description: this analysis starts with a taxon name, resolves to an OTT ID, then\n# pulls the subtree below this taxon\n# \n# input: taxon - (string) taxon name to serve as the root of the returned tree\n# output: subtree -  subtree returned by OpenTree\n#\n\nimport requests\nimport json\n\noutrows = []\noutstring = ''\n\n\n# curl -POST https://api.opentreeoflife.org/v3/tnrs/match_names -H \"content-type:application/json\" \n# -d '{\"names\":[\"Aster\",\"Symphyotrichum\",\"Barnadesia\"]}'\n\n# pack the names into a payload and perform the OpenTree lookup using v3, which has same syntax as v2.\npayload = json.dumps({'names': [taxonName]})\noutstring = outstring+'payload: '+payload\nheaders = {'content-type':'application/json'}\nresp = requests.post('https://api.opentreeoflife.org/v2/tnrs/match_names',data=payload,headers=headers)\noutstring = outstring+' \\nresponse: '+resp.text\n\ntry:\n    returnedrecs = resp.json()['results']\n    thisresult = returnedrecs[0]\n    candidate = thisresult['matches'][0]\n    ottName = candidate['ot:ottTaxonName']\n    ottId = candidate['ot:ottId']\n    outstring += '\\n returned name: '+ottName+' ottId: '+str(ottId)\nexcept:\n    outstring = outstring+'\\nerror in OpenTree TNRS lookup. No result returned'\n\n\n\n# now return the subtree from a given OTT ID\n# curl -X POST https://api.opentreeoflife.org/v3/tree_of_life/subtree -H \"content-type:application/json\" -d '{\"node_id\":\"ott803675\"}'\n\n# build an OTL query to return the matching ottId we want to use to request taxa \nottIdNameString = 'ott'+str(ottId)\npayload = json.dumps({'node_id' : ottIdNameString})\nheaders = {'content-type':'application/json'}\nquerystring = 'https://api.opentreeoflife.org/v3/tree_of_life/subtree'\nrespTree = requests.post(querystring,data=payload,headers=headers)\noutstring = outstring+' \\n tree response: \\n'+respTree.text\ntry:\n    respTreeJson = respTree.json()\n    subtree = respTreeJson['newick']\n    # add an extra set of parenthesis around the newick tree returned to fit the original definition of Newick format\n    #subtree = '('+subtree[:-1]+');'\n    outstring += '\\n extracted subtree: '+subtree\n    #subtree = ';'\nexcept:\n    subtree = ';'\n    outstring = outstring+'\\nerror returning OpenTree Subtree'\n  \n    \n"}, "visualization": false, "x": 198, "y": 133}, {"girderId": "590f258a54cdbf37f0651151", "modified": "2017-05-07T13:47:54.540000+00:00", "name": "Prune Tree On Levels Below Root", "task": {"description": "Prune an input tree a specified number of levels down from the root.  If nodes on the input tree don't have an existing name, a unique name (e.g. \"node1\",\"node2\", etc.) is assigned to them because they may end up being tips if they are on the bottom level.  This way tips always have names.  If the input tree had node names, they will be preserved. Incoming branch lengths (or lack thereof) will be preserved. ", "inputs": [{"description": "input tree to be pruned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}, {"default": {"data": "2", "format": "text", "type": "string"}, "description": "the number of levels to pass through to the output tree; levels below are pruned", "format": "number", "id": "numLevels", "name": "number of levels to pass through", "type": "number"}], "mode": "python", "name": "Prune Tree On Levels Below Root", "outputs": [{"format": "nested", "id": "prunedTree", "name": "Pruned Output Tree", "type": "tree"}], "script": "# traverse a tree in nested format and prune it a selectable set of levels below the root.  This can be used\n# to create family or order-level hierarchies instead of traversing all the way to the leaves.\n\n# C. Lisle\n# KnowledgeVis, LLC\n\n# released under the Apache 2.0 open-source license\n\n# inputs:\n#    tree - tree in nested format \n#   numLevels - how deep to traverse (1=children of root, 2=children of children of root, etc...)\n# outputs:\n#    prunedtree - starting at the same root, return a smaller tree\n\n# for a description of the nested tree format, please see the tree format description at http://girder_worker.readthedocs.org\n\nnodenumber = 1\n\n# recursive traversal of tree in nested format.  Once a taxon is reached, invoke the 'taxonOperation()' routine with the taxon node\ndef traverseNestedTree(treenode,levelsRemaining):\n    global nodenumber\n    # if there is no name on this node, assign a name, since it might become a tip\n    if len(treenode['node_data']['node name'])==0:\n        treenode['node_data']['node name'] = 'node'+str(nodenumber)\n        nodenumber += 1\n    if levelsRemaining >0:\n        # look at the current tree node and see if there are children or not\n        if 'children' in treenode.keys():\n            #case for a hierarchy node, traverse to all the children\n            for node in treenode['children']:\n                traverseNestedTree(node,levelsRemaining-1)\n        else:\n            pass\n    else:\n        # prune the tree by deleting the children field, if it is there\n        if 'children' in treenode.keys():\n            del treenode['children']\n    \n# run the traversal.  The tree is changed in place\ntraverseNestedTree(tree,numLevels)\nprunedTree = tree\n\n\n"}, "visualization": false, "x": 441, "y": 184.99998474121094}, {"girderId": "58fd208c54cdbf552d799306", "modified": "2017-04-23T21:45:48.367000+00:00", "name": "Tip Names from Nested Tree", "task": {"description": "", "inputs": [{"description": "nested format tree to extract node names from", "format": "nested", "name": "tree", "type": "tree"}], "mode": "python", "name": "Tip Names from Nested Tree", "outputs": [{"description": "single column table with species names", "format": "rows", "name": "nametable", "type": "table"}], "script": "\n# traverse a tree in nested format and output a single column table with species names from the tree taxa\n\n# C. Lisle\n# KnowledgeVis, LLC\n\n# released under the Apache 2.0 open-source license\n\n# inputs:\n#    tree - tree in nested format \n# outputs:\n#    nametable - table:rows with single column containing species names from the tree taxa\n\nnameList = []\n\n# this is invoked for each taxon node in the tree.  If the taxon is named, the name is added to a global list\ndef taxonOperation(node):\n    if 'node name' in node['node_data'].keys():\n        nameList.append(node['node_data']['node name'])\n\n        \n# recursive traversal of tree in nested format.  Once a taxon is reached, invoke the 'taxonOperation()' routine with the taxon node\ndef traverseNestedTree(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            traverseNestedTree(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        taxonOperation(treenode)\n        \n# run the traversal and copy the output name list\ntraverseNestedTree(tree)\n\n# prepare the output single column table of species names\nnametable = {}\nnametable['fields'] = []\nnametable['rows'] = []\nnametable['fields'].append('name')\n\nfor name in nameList:\n    outRecord = {}\n    outRecord['name'] = name\n    nametable['rows'].append(outRecord)\n    \n\n"}, "visualization": false, "x": 649, "y": 67.00001525878906}, {"girderId": "590df31d54cdbf2d4cbf0811", "modified": "2017-05-06T16:28:04.112000+00:00", "name": "Convert Table of OpenTree Names to Scientific Names", "task": {"description": "", "inputs": [{"description": "table of OTL format names, such as 'genus_species_ott12344'", "format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Convert Table of OpenTree Names to Scientific Names", "outputs": [{"description": "output table with traditional species names 'genus species'", "format": "rows", "id": "outtable", "name": "outtable", "type": "table"}], "script": "\n# convert a table of OTL format of genus_species_ottXXXX names into standard \"genus species\".  Single names (taxonomy)\n# are passed through without the _ottXXX postpended, as well. \n\ncolname = table['fields'][0]\noutrows = []\nfor row in table['rows']:\n    outrow = {}\n    splitname = row[colname].split('_')\n    if len(splitname) == 3:\n        outname = splitname[0] + ' ' + splitname[1]\n    elif len(splitname) == 2:\n        outname = splitname[0]\n    else:\n        #complex case:  remove last _ottXXX and change to spaces, but leave all components\n        outname = ''\n        for i in range(len(splitname)-1):\n            outname = outname + splitname[i] + ' '\n        # strip off the final space\n        if len(outname)> 1:\n            outname = outname[:-1]\n    outrow[colname] = outname\n    outrows.append(outrow)\n    \nouttable = {}\nouttable['fields'] = [colname]\nouttable['rows'] = outrows\n    \n    "}, "visualization": false, "x": 821, "y": 200}, {"girderId": "590fbb9054cdbf37f06511bd", "modified": "2017-05-08T00:42:41.150723+00:00", "name": "Table Pass Single Scientific Names Only", "task": {"description": "This method filters a table of scientific names.  It eliminates empty names and names that are specific to a single species (e.g. \"genus species\").  It was initially conceived to preprocess tip names extracted from the higher portions of OpenTree synthetic tree, in order to drive tip comparisons between study trees and the OpenTree.", "inputs": [{"description": "table of scientific names", "format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Table Pass Single Scientific Names Only", "outputs": [{"description": "filtered output table with rows suitable for use with tip matching algortihms", "format": "rows", "id": "outtable", "name": "outtable", "type": "table"}], "script": "# look through the rows of a table.  Pass only the ones with a single word (not a \"genus species\"), don't pass \n# any empty entries, and don't pass any names that start with node or _ott\n\nouttable = {}\nouttable['fields'] = table['fields']\nouttable['rows'] = []\n\nfirstcol = table['fields'][0]\nfor row in table['rows']:\n    taxon = row[firstcol]\n    # split on the space to detect scientific names\n    splitname = row[firstcol].split(' ')\n    # only output a cleaned supset of the rows, with single names\n    if (len(taxon)>0) and (len(splitname)==1) and (taxon[0:4] != 'node') and (taxon[0:4] != '_ott'):\n        outtable['rows'].append(row)\n        \n        "}, "visualization": false, "x": 1083, "y": 202}]}}, "name": "WF curate family names for clade analysis", "size": 0, "updated": "2017-05-08T00:51:10.089000+00:00"}