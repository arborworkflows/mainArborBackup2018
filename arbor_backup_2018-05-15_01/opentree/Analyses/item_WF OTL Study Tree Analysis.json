{"_id": "58fd808c54cdbf01a433afc9", "_modelType": "item", "baseParentId": "58fad7c954cdbf552d799223", "baseParentType": "collection", "created": "2017-04-24T04:35:24.366000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "58fad7c954cdbf552d799225", "meta": {"analysis": {"connections": [{"input": "studyTable", "input_step": "OpenTree Enumerate Trees from Study List", "output": "returnedStudies", "output_step": "Explore Study Trees (Return Tree Info) from Taxon Name"}, {"input": "taxonName", "input_step": "Explore Study Trees (Return Tree Info) from Taxon Name", "name": "taxonName"}, {"name": "returnedStudies", "output": "returnedStudies", "output_step": "Explore Study Trees (Return Tree Info) from Taxon Name"}, {"input": "table", "input_step": "Loop Accumulate Unique Tree Tips from Study Tree Table", "output": "treeTable", "output_step": "OpenTree Enumerate Trees from Study List"}, {"name": "accumulatedTips", "output": "accumulatedTips", "output_step": "Loop Accumulate Unique Tree Tips from Study Tree Table"}], "description": "", "inputs": [{"format": "text", "id": "taxonName", "name": "taxonName", "type": "string", "x": 28, "y": 204}], "mode": "workflow", "name": "WF OTL Study Tree Analysis", "outputs": [{"format": "rows", "id": "accumulatedTips", "name": "accumulatedTips", "type": "table", "x": 1055, "y": 167}, {"format": "rows", "id": "returnedStudies", "name": "returnedStudies", "type": "table", "x": 578, "y": 16}], "steps": [{"girderId": "58fb9a0554cdbf552d799227", "modified": "2017-04-23T21:17:55.478000+00:00", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "task": {"description": "", "inputs": [{"format": "text", "name": "taxonName", "type": "string"}], "mode": "python", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "outputs": [{"format": "rows", "name": "returnedStudies", "type": "table"}], "script": "#\n# OpenTreeExploreNamesFromString\n#\n# description: this analysis expects a comma separated list consisting of scientific names.\n# The analysis consults the OpenTree API and extracts canonical names from the OpenTree taxonomy.\n# The output table consists of several columns containint the OpenTree name and taxonomy ID and other relevant information. \n# \n# input: taxonName - single scientific name(s) separated by commas\n# output: outTable -  table with list of studies associated with the taxonname passed as a parameter.\n#\n# maxReturnLength - (could be a parameter, but is defaulted below) max amount of rows of lookups to return\n\nimport requests\nimport unicodedata\n\noutrows = []\nstringdebug = ''\n\nreturncount = 0\n\n\n# ideally, this could be a parameter, but this is an exploratory module, so assume a limit and don't make the \n# user enter it every time\nmaxReturnLength = 100\n\n# build an OTL query to return the matching ottId we want to use to request taxa \npayload = {'property' :'ot:ottTaxonName','value': taxonName,'verbose':'true'}\nresp = requests.post('https://api.opentreeoflife.org/v3/studies/find_trees',data=payload)\n\nreturnedrecs = resp.json()['matched_studies']\n\n# look through all the return records from OpenTree. include them all in the output, but especially\n# traverse the list of trees included in the studies and printout a string that discusses the trees included \n# in the studies\n\nfor index in range(len(returnedrecs)):\n    thisresult = returnedrecs[index]\n    returncount += 1\n    outrows.append(thisresult)\n    # for each returned tree in this study, add some info about it\n    treeinfostring = ''\n    trees = thisresult['matched_trees']\n    for tree in trees:\n        # print out info about the tree, work hard to suppress wierdness from unicode values so the analysis will generally run\n        treeinfostring += \"treeid: \"+unicodedata.normalize('NFKD',tree['oti_tree_id']).encode('ascii','ignore')\n        # only some trees will have branch lengths, so check for existance before printing the info.  \n        if 'ot:branchLengthMode' in tree.keys():\n            # Then some trees have the existance of the field but there is no value entered, so assume these should be filtered out\n            if len(tree['ot:branchLengthMode']) >0:\n                treeinfostring += \" branchlengths: \"+unicodedata.normalize('NFKD',tree['ot:branchLengthMode']).encode('ascii','ignore')\n        treeinfostring += \"; \"\n        #treeinfo.append(treeinfostring)\n    thisresult['tree summary'] = treeinfostring\n        \n\n\n    # if we have already returned the max number of rows, break out of the loop             \n    if returncount>maxReturnLength:\n        break;\n\n\n# build the headers for the output table, the return might be empty, so do crash, just return an empty table\noutColumns = []\nif len(returnedrecs) > 0:\n    for column in returnedrecs[0].keys():\n        outColumns.append(column)\n    \n\n# setup the output in table:rows format with the headers explicitly listed\nreturnedStudies = {'fields': outColumns,\n            'rows':  outrows}\n            \n     "}, "visualization": false, "x": 204, "y": 66}, {"girderId": "58fd1a1a54cdbf552d7992d9", "modified": "2017-04-23T21:32:20.255000+00:00", "name": "OpenTree Enumerate Trees from Study List", "task": {"description": "This method expects to receive a table of study summaries for a taxon returned from OpenTree.  An OpenTree API call (phylesystem, really) is used to build a table listing each tree that is stored in each study from the input table.  A table, one row per tree, is created as output", "inputs": [{"description": "A list of studies in a tabletable created from a study query from OpenTree based on a taxon name", "format": "rows", "id": "studyTable", "name": "Study Summary Table", "type": "table"}], "mode": "python", "name": "OpenTree Enumerate Trees from Study List", "outputs": [{"description": "Each tree stored in a study is output on its own line.  The headers are 'studyID' and 'treeID'", "format": "rows", "id": "treeTable", "name": "Enumerated Table of Study Trees from OpenTree", "type": "table"}], "script": "\n# Given a table of tree studies from OpenTree, explore each study and create an output table with one row for every tree found. \n# Trees are indexed by study, then trees within each study\n\n# input: studyTable study table (with StudyID column hearder)\n# output: treeTable - a two columnn table with (studyID, treeID) pairs for all trees found in the studies\n\n# prepare the output tree list\n\nimport requests\nimport json\n\ntreeTable = {}\ntreeTable['fields'] = ['ot:studyId','ot:treeId']\ntreeTable['rows'] = []\n\n# go through each row of the input study table and find out what trees are in this study\n\nfor row in studyTable['rows']:\n    study = row['ot:studyId']\n    # this call returns the list of trees in the study\n    resp = requests.get('http://api.opentreeoflife.org/v3/study/'+study+'/tree')\n    jsonReturn = resp.json()\n    # go through the list and build an output table\n    for key in jsonReturn.keys():\n        outrow = {}\n        outrow['ot:studyId'] = study\n        outrow['ot:treeId'] = key\n        treeTable['rows'].append(outrow)\n"}, "visualization": false, "x": 457, "y": 174}, {"girderId": "590ccaaa54cdbf7a5dff86aa", "modified": "2017-05-05T19:12:36.799000+00:00", "name": "Loop Accumulate Unique Tree Tips from Study Tree Table", "task": {"description": "", "inputs": [{"format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Loop Accumulate Unique Tree Tips from Study Tree Table", "outputs": [{"format": "rows", "id": "accumulatedTips", "name": "accumulatedTips", "type": "table"}, {"description": "size of final table of unique names", "format": "number", "id": "uniqueTipCount", "name": "Unique Tip Count", "type": "number"}, {"description": "count of total number of tips from all tries, even if they are duplicates", "format": "number", "id": "duplicatedTipCount", "name": "Total Tip Count including duplicates", "type": "number"}], "script": "import json\nimport requests\nimport girder_worker\nimport girder_client\n\n# this is a looping method that goes through a study tree table and repeatedly calls a subordinate workflow to retrieve the tree \n# and get its list of tree tips.  First, the subordinate analysis is looked up by name using the Girder Client. \n\ndebugString = ''\n\n#print 'input table:',table\n\n# create instance of the girder client\n#gc = girder_client.GirderClient(apiUrl='http://arbor.arborworkflows.com/girder/api/v1')\ngc = girder_client.GirderClient(apiUrl='http://localhost:8080/girder/api/v1')\n#gc = girder_client.GirderClient('localhost',8080)\n# lookup the analysis in a known location (the opentree collection)\nmethodToLoop = \"WF Tree Tips from Study Tree\"\nmethodSearchResults = gc.resourceLookup('/collection/opentree/Analyses/'+methodToLoop)\nanalysis = methodSearchResults['meta']['analysis']\nprint 'analysis ID:',analysis\n\ndebugString += json.dumps(analysis)\ndebugString += '\\n'\n\n# now we have a JSON description of the analysis method to run inside the loop. Start with an empty output and loop through \n# the input, calling the subordinate method for each row of the input table\n\nduplicatedTips = []\n\nfor row in table['rows']:\n    subinputs = {\n        'studyID': {'format': 'string', 'data': row['ot:studyId']},\n        'treeID': {'format': 'string', 'data': row['ot:treeId']}\n    }\n    # run the analysis\n    #debugString += 'about to run\\n'\n    suboutputs = girder_worker.run(analysis, subinputs,{'result': {'format': 'rows'}})\n    #debugString += 'completed run\\n'\n\n    # get the tips from this tree and output a debug status containing the treename\n    tipsFromOneTree = suboutputs['nametable']['data']\n    debugString += 'tree: '+row['ot:treeId']+'\\n'\n    \n    # add the discovered tips from one tree into a temporary list that will be used to \n    # combine non-unique entries before generating the final output.  We pick out the first\n    # column of the table, regardless of what column header was used\n    for newrow in tipsFromOneTree['rows']:\n        duplicatedTips.append(newrow[tipsFromOneTree['fields'][0]])\n\n# now combine non-unique tips\nuniqueTips = set(duplicatedTips)\n\n# prepare final output datastructure (unique tip table and counts)\naccumulatedTips = {}\naccumulatedTips['fields'] = ['name']\naccumulatedTips['rows'] = []\n\nfor x in uniqueTips:\n    newrow = {}\n    newrow['name'] = x\n    accumulatedTips['rows'].append(newrow)\n\nduplicatedTipCount = len(duplicatedTips)\nuniqueTipCount = len(uniqueTips)\n\n"}, "visualization": false, "x": 774, "y": 170}]}}, "name": "WF OTL Study Tree Analysis", "size": 0, "updated": "2017-05-06T16:52:20.267000+00:00"}