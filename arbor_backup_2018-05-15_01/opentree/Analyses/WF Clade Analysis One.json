{"connections": [{"input": "taxonName", "input_step": "WF OTL Study Tree Analysis", "name": "taxonName"}, {"input": "Taxon Root of Subtree", "input_step": "WF Extract OpenTree Subtree from Taxon", "name": "taxonName"}, {"input": "tree", "input_step": "Tip Names from Nested Tree", "output": "outtree", "output_step": "WF Extract OpenTree Subtree from Taxon"}, {"input": "table", "input_step": "Convert Table of OpenTree Names to Scientific Names", "output": "nametable", "output_step": "Tip Names from Nested Tree"}, {"input": "table1", "input_step": "Compare Tree Tip Lists", "output": "accumulatedTips", "output_step": "WF OTL Study Tree Analysis"}, {"input": "table2", "input_step": "Compare Tree Tip Lists", "output": "outtable", "output_step": "Convert Table of OpenTree Names to Scientific Names"}, {"name": "table1UniqueCount", "output": "table1UniqueCount", "output_step": "Compare Tree Tip Lists"}, {"name": "table2UniqueCount", "output": "table2UniqueCount", "output_step": "Compare Tree Tip Lists"}, {"name": "tablesCommonCount", "output": "tablesCommonCount", "output_step": "Compare Tree Tip Lists"}, {"name": "returnedStudies", "output": "returnedStudies", "output_step": "WF OTL Study Tree Analysis"}, {"name": "accumulatedTips", "output": "accumulatedTips", "output_step": "WF OTL Study Tree Analysis"}, {"name": "outtable", "output": "outtable", "output_step": "Convert Table of OpenTree Names to Scientific Names"}], "description": "", "inputs": [{"format": "text", "id": "taxonName", "name": "taxonName", "type": "string", "x": 28, "y": 49}], "mode": "workflow", "name": "WF Clade Analysis One", "outputs": [{"description": "count of entries found only in table1", "format": "text", "id": "table1UniqueCount", "name": "table1UniqueCount", "type": "string", "x": 1097, "y": 51}, {"description": "count of entries found only in table2 (but not in table1)", "format": "text", "id": "table2UniqueCount", "name": "table2UniqueCount", "type": "string", "x": 1107, "y": 175}, {"description": "count of entries found in both tables", "format": "text", "id": "tablesCommonCount", "name": "tablesCommonCount", "type": "string", "x": 1067, "y": 326}, {"format": "rows", "id": "returnedStudies", "name": "returnedStudies", "type": "table", "x": 764, "y": 11}, {"format": "rows", "id": "accumulatedTips", "name": "accumulated Study Tips", "type": "table", "x": 931, "y": 589}, {"description": "output table with traditional species names 'genus species'", "format": "rows", "id": "outtable", "name": "OpenTree tips", "type": "table", "x": 971, "y": 466}], "steps": [{"girderId": "58fd808c54cdbf01a433afc9", "modified": "2017-05-06T16:52:20.267421+00:00", "name": "WF OTL Study Tree Analysis", "task": {"connections": [{"input": "studyTable", "input_step": "OpenTree Enumerate Trees from Study List", "output": "returnedStudies", "output_step": "Explore Study Trees (Return Tree Info) from Taxon Name"}, {"input": "taxonName", "input_step": "Explore Study Trees (Return Tree Info) from Taxon Name", "name": "taxonName"}, {"name": "returnedStudies", "output": "returnedStudies", "output_step": "Explore Study Trees (Return Tree Info) from Taxon Name"}, {"input": "table", "input_step": "Loop Accumulate Unique Tree Tips from Study Tree Table", "output": "treeTable", "output_step": "OpenTree Enumerate Trees from Study List"}, {"name": "accumulatedTips", "output": "accumulatedTips", "output_step": "Loop Accumulate Unique Tree Tips from Study Tree Table"}], "description": "", "inputs": [{"format": "text", "id": "taxonName", "name": "taxonName", "type": "string", "x": 28, "y": 204}], "mode": "workflow", "name": "WF OTL Study Tree Analysis", "outputs": [{"format": "rows", "id": "accumulatedTips", "name": "accumulatedTips", "type": "table", "x": 1055, "y": 167}, {"format": "rows", "id": "returnedStudies", "name": "returnedStudies", "type": "table", "x": 578, "y": 16}], "steps": [{"girderId": "58fb9a0554cdbf552d799227", "modified": "2017-04-23T21:17:55.478000+00:00", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "task": {"description": "", "inputs": [{"format": "text", "name": "taxonName", "type": "string"}], "mode": "python", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "outputs": [{"format": "rows", "name": "returnedStudies", "type": "table"}], "script": "#\n# OpenTreeExploreNamesFromString\n#\n# description: this analysis expects a comma separated list consisting of scientific names.\n# The analysis consults the OpenTree API and extracts canonical names from the OpenTree taxonomy.\n# The output table consists of several columns containint the OpenTree name and taxonomy ID and other relevant information. \n# \n# input: taxonName - single scientific name(s) separated by commas\n# output: outTable -  table with list of studies associated with the taxonname passed as a parameter.\n#\n# maxReturnLength - (could be a parameter, but is defaulted below) max amount of rows of lookups to return\n\nimport requests\nimport unicodedata\n\noutrows = []\nstringdebug = ''\n\nreturncount = 0\n\n\n# ideally, this could be a parameter, but this is an exploratory module, so assume a limit and don't make the \n# user enter it every time\nmaxReturnLength = 100\n\n# build an OTL query to return the matching ottId we want to use to request taxa \npayload = {'property' :'ot:ottTaxonName','value': taxonName,'verbose':'true'}\nresp = requests.post('https://api.opentreeoflife.org/v3/studies/find_trees',data=payload)\n\nreturnedrecs = resp.json()['matched_studies']\n\n# look through all the return records from OpenTree. include them all in the output, but especially\n# traverse the list of trees included in the studies and printout a string that discusses the trees included \n# in the studies\n\nfor index in range(len(returnedrecs)):\n    thisresult = returnedrecs[index]\n    returncount += 1\n    outrows.append(thisresult)\n    # for each returned tree in this study, add some info about it\n    treeinfostring = ''\n    trees = thisresult['matched_trees']\n    for tree in trees:\n        # print out info about the tree, work hard to suppress wierdness from unicode values so the analysis will generally run\n        treeinfostring += \"treeid: \"+unicodedata.normalize('NFKD',tree['oti_tree_id']).encode('ascii','ignore')\n        # only some trees will have branch lengths, so check for existance before printing the info.  \n        if 'ot:branchLengthMode' in tree.keys():\n            # Then some trees have the existance of the field but there is no value entered, so assume these should be filtered out\n            if len(tree['ot:branchLengthMode']) >0:\n                treeinfostring += \" branchlengths: \"+unicodedata.normalize('NFKD',tree['ot:branchLengthMode']).encode('ascii','ignore')\n        treeinfostring += \"; \"\n        #treeinfo.append(treeinfostring)\n    thisresult['tree summary'] = treeinfostring\n        \n\n\n    # if we have already returned the max number of rows, break out of the loop             \n    if returncount>maxReturnLength:\n        break;\n\n\n# build the headers for the output table, the return might be empty, so do crash, just return an empty table\noutColumns = []\nif len(returnedrecs) > 0:\n    for column in returnedrecs[0].keys():\n        outColumns.append(column)\n    \n\n# setup the output in table:rows format with the headers explicitly listed\nreturnedStudies = {'fields': outColumns,\n            'rows':  outrows}\n            \n     "}, "visualization": false, "x": 204, "y": 66}, {"girderId": "58fd1a1a54cdbf552d7992d9", "modified": "2017-04-23T21:32:20.255000+00:00", "name": "OpenTree Enumerate Trees from Study List", "task": {"description": "This method expects to receive a table of study summaries for a taxon returned from OpenTree.  An OpenTree API call (phylesystem, really) is used to build a table listing each tree that is stored in each study from the input table.  A table, one row per tree, is created as output", "inputs": [{"description": "A list of studies in a tabletable created from a study query from OpenTree based on a taxon name", "format": "rows", "id": "studyTable", "name": "Study Summary Table", "type": "table"}], "mode": "python", "name": "OpenTree Enumerate Trees from Study List", "outputs": [{"description": "Each tree stored in a study is output on its own line.  The headers are 'studyID' and 'treeID'", "format": "rows", "id": "treeTable", "name": "Enumerated Table of Study Trees from OpenTree", "type": "table"}], "script": "\n# Given a table of tree studies from OpenTree, explore each study and create an output table with one row for every tree found. \n# Trees are indexed by study, then trees within each study\n\n# input: studyTable study table (with StudyID column hearder)\n# output: treeTable - a two columnn table with (studyID, treeID) pairs for all trees found in the studies\n\n# prepare the output tree list\n\nimport requests\nimport json\n\ntreeTable = {}\ntreeTable['fields'] = ['ot:studyId','ot:treeId']\ntreeTable['rows'] = []\n\n# go through each row of the input study table and find out what trees are in this study\n\nfor row in studyTable['rows']:\n    study = row['ot:studyId']\n    # this call returns the list of trees in the study\n    resp = requests.get('http://api.opentreeoflife.org/v3/study/'+study+'/tree')\n    jsonReturn = resp.json()\n    # go through the list and build an output table\n    for key in jsonReturn.keys():\n        outrow = {}\n        outrow['ot:studyId'] = study\n        outrow['ot:treeId'] = key\n        treeTable['rows'].append(outrow)\n"}, "visualization": false, "x": 457, "y": 174}, {"girderId": "590ccaaa54cdbf7a5dff86aa", "modified": "2017-05-05T19:12:36.799000+00:00", "name": "Loop Accumulate Unique Tree Tips from Study Tree Table", "task": {"description": "", "inputs": [{"format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Loop Accumulate Unique Tree Tips from Study Tree Table", "outputs": [{"format": "rows", "id": "accumulatedTips", "name": "accumulatedTips", "type": "table"}, {"description": "size of final table of unique names", "format": "number", "id": "uniqueTipCount", "name": "Unique Tip Count", "type": "number"}, {"description": "count of total number of tips from all tries, even if they are duplicates", "format": "number", "id": "duplicatedTipCount", "name": "Total Tip Count including duplicates", "type": "number"}], "script": "import json\nimport requests\nimport girder_worker\nimport girder_client\n\n# this is a looping method that goes through a study tree table and repeatedly calls a subordinate workflow to retrieve the tree \n# and get its list of tree tips.  First, the subordinate analysis is looked up by name using the Girder Client. \n\ndebugString = ''\n\n#print 'input table:',table\n\n# create instance of the girder client\n#gc = girder_client.GirderClient(apiUrl='http://arbor.arborworkflows.com/girder/api/v1')\ngc = girder_client.GirderClient(apiUrl='http://localhost:8080/girder/api/v1')\n#gc = girder_client.GirderClient('localhost',8080)\n# lookup the analysis in a known location (the opentree collection)\nmethodToLoop = \"WF Tree Tips from Study Tree\"\nmethodSearchResults = gc.resourceLookup('/collection/opentree/Analyses/'+methodToLoop)\nanalysis = methodSearchResults['meta']['analysis']\nprint 'analysis ID:',analysis\n\ndebugString += json.dumps(analysis)\ndebugString += '\\n'\n\n# now we have a JSON description of the analysis method to run inside the loop. Start with an empty output and loop through \n# the input, calling the subordinate method for each row of the input table\n\nduplicatedTips = []\n\nfor row in table['rows']:\n    subinputs = {\n        'studyID': {'format': 'string', 'data': row['ot:studyId']},\n        'treeID': {'format': 'string', 'data': row['ot:treeId']}\n    }\n    # run the analysis\n    #debugString += 'about to run\\n'\n    suboutputs = girder_worker.run(analysis, subinputs,{'result': {'format': 'rows'}})\n    #debugString += 'completed run\\n'\n\n    # get the tips from this tree and output a debug status containing the treename\n    tipsFromOneTree = suboutputs['nametable']['data']\n    debugString += 'tree: '+row['ot:treeId']+'\\n'\n    \n    # add the discovered tips from one tree into a temporary list that will be used to \n    # combine non-unique entries before generating the final output.  We pick out the first\n    # column of the table, regardless of what column header was used\n    for newrow in tipsFromOneTree['rows']:\n        duplicatedTips.append(newrow[tipsFromOneTree['fields'][0]])\n\n# now combine non-unique tips\nuniqueTips = set(duplicatedTips)\n\n# prepare final output datastructure (unique tip table and counts)\naccumulatedTips = {}\naccumulatedTips['fields'] = ['name']\naccumulatedTips['rows'] = []\n\nfor x in uniqueTips:\n    newrow = {}\n    newrow['name'] = x\n    accumulatedTips['rows'].append(newrow)\n\nduplicatedTipCount = len(duplicatedTips)\nuniqueTipCount = len(uniqueTips)\n\n"}, "visualization": false, "x": 774, "y": 170}]}, "visualization": false, "x": 453, "y": 80}, {"girderId": "590cc4dc54cdbf7a5dff86a4", "modified": "2017-05-05T18:32:01.113000+00:00", "name": "WF Extract OpenTree Subtree from Taxon", "task": {"connections": [{"input": "tree", "input_step": "Assign Tree Branch Branch Lengths If Missing", "output": "subtree", "output_step": "OpenTree Return Subtree from Taxon"}, {"name": "outtree", "output": "outtree", "output_step": "Assign Tree Branch Branch Lengths If Missing"}, {"input": "taxonName", "input_step": "OpenTree Return Subtree from Taxon", "name": "Taxon Root of Subtree"}], "description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "Taxon Root of Subtree", "name": "Taxon Root of Subtree", "type": "string", "x": 52, "y": 256}], "mode": "workflow", "name": "WF Extract OpenTree Subtree from Taxon", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree", "x": 893, "y": 220}], "steps": [{"girderId": "590b4b1e54cdbf7a5dff8634", "modified": "2017-05-04T15:39:11.050000+00:00", "name": "Assign Tree Branch Branch Lengths If Missing", "task": {"description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}], "mode": "python", "name": "Assign Tree Branch Branch Lengths If Missing", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree"}], "script": "nodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \nouttree = tree\nassignEdgeWeightsIfMissing(outtree)\n"}, "visualization": false, "x": 593, "y": 220}, {"girderId": "590cc43c54cdbf7a5dff8698", "modified": "2017-05-05T18:29:06.614990+00:00", "name": "OpenTree Return Subtree from Taxon", "task": {"description": "", "inputs": [{"description": "taxon to use as the root of an extracted OpenTree subtree", "format": "text", "id": "taxonName", "name": "Taxon Root of Subtree", "type": "string"}], "mode": "python", "name": "OpenTree Return Subtree from Taxon", "outputs": [{"description": "returned OpenTree subtree", "format": "newick", "id": "subtree", "name": "OpenTree subtree", "type": "tree"}, {"format": "text", "id": "outstring", "name": "Debug String", "type": "string"}], "script": "#\n# Return an OpenTree Subtree given a starting taxon\n#\n# description: this analysis starts with a taxon name, resolves to an OTT ID, then\n# pulls the subtree below this taxon\n# \n# input: taxon - (string) taxon name to serve as the root of the returned tree\n# output: subtree -  subtree returned by OpenTree\n#\n\nimport requests\nimport json\n\noutrows = []\noutstring = ''\n\n\n# curl -POST https://api.opentreeoflife.org/v3/tnrs/match_names -H \"content-type:application/json\" \n# -d '{\"names\":[\"Aster\",\"Symphyotrichum\",\"Barnadesia\"]}'\n\n# pack the names into a payload and perform the OpenTree lookup using v3, which has same syntax as v2.\npayload = json.dumps({'names': [taxonName]})\noutstring = outstring+'payload: '+payload\nheaders = {'content-type':'application/json'}\nresp = requests.post('https://api.opentreeoflife.org/v2/tnrs/match_names',data=payload,headers=headers)\noutstring = outstring+' \\nresponse: '+resp.text\n\ntry:\n    returnedrecs = resp.json()['results']\n    thisresult = returnedrecs[0]\n    candidate = thisresult['matches'][0]\n    ottName = candidate['ot:ottTaxonName']\n    ottId = candidate['ot:ottId']\n    outstring += '\\n returned name: '+ottName+' ottId: '+str(ottId)\nexcept:\n    outstring = outstring+'\\nerror in OpenTree TNRS lookup. No result returned'\n\n\n\n# now return the subtree from a given OTT ID\n# curl -X POST https://api.opentreeoflife.org/v3/tree_of_life/subtree -H \"content-type:application/json\" -d '{\"node_id\":\"ott803675\"}'\n\n# build an OTL query to return the matching ottId we want to use to request taxa \nottIdNameString = 'ott'+str(ottId)\npayload = json.dumps({'node_id' : ottIdNameString})\nheaders = {'content-type':'application/json'}\nquerystring = 'https://api.opentreeoflife.org/v3/tree_of_life/subtree'\nrespTree = requests.post(querystring,data=payload,headers=headers)\noutstring = outstring+' \\n tree response: \\n'+respTree.text\ntry:\n    respTreeJson = respTree.json()\n    subtree = respTreeJson['newick']\n    # add an extra set of parenthesis around the newick tree returned to fit the original definition of Newick format\n    #subtree = '('+subtree[:-1]+');'\n    outstring += '\\n extracted subtree: '+subtree\n    #subtree = ';'\nexcept:\n    subtree = ';'\n    outstring = outstring+'\\nerror returning OpenTree Subtree'\n  \n    \n"}, "visualization": false, "x": 339, "y": 261}]}, "visualization": false, "x": 166, "y": 262}, {"girderId": "58fd208c54cdbf552d799306", "modified": "2017-04-23T21:45:48.367000+00:00", "name": "Tip Names from Nested Tree", "task": {"description": "", "inputs": [{"description": "nested format tree to extract node names from", "format": "nested", "name": "tree", "type": "tree"}], "mode": "python", "name": "Tip Names from Nested Tree", "outputs": [{"description": "single column table with species names", "format": "rows", "name": "nametable", "type": "table"}], "script": "\n# traverse a tree in nested format and output a single column table with species names from the tree taxa\n\n# C. Lisle\n# KnowledgeVis, LLC\n\n# released under the Apache 2.0 open-source license\n\n# inputs:\n#    tree - tree in nested format \n# outputs:\n#    nametable - table:rows with single column containing species names from the tree taxa\n\nnameList = []\n\n# this is invoked for each taxon node in the tree.  If the taxon is named, the name is added to a global list\ndef taxonOperation(node):\n    if 'node name' in node['node_data'].keys():\n        nameList.append(node['node_data']['node name'])\n\n        \n# recursive traversal of tree in nested format.  Once a taxon is reached, invoke the 'taxonOperation()' routine with the taxon node\ndef traverseNestedTree(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            traverseNestedTree(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        taxonOperation(treenode)\n        \n# run the traversal and copy the output name list\ntraverseNestedTree(tree)\n\n# prepare the output single column table of species names\nnametable = {}\nnametable['fields'] = []\nnametable['rows'] = []\nnametable['fields'].append('name')\n\nfor name in nameList:\n    outRecord = {}\n    outRecord['name'] = name\n    nametable['rows'].append(outRecord)\n    \n\n"}, "visualization": false, "x": 405, "y": 315}, {"girderId": "590df31d54cdbf2d4cbf0811", "modified": "2017-05-06T16:28:04.112000+00:00", "name": "Convert Table of OpenTree Names to Scientific Names", "task": {"description": "", "inputs": [{"description": "table of OTL format names, such as 'genus_species_ott12344'", "format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Convert Table of OpenTree Names to Scientific Names", "outputs": [{"description": "output table with traditional species names 'genus species'", "format": "rows", "id": "outtable", "name": "outtable", "type": "table"}], "script": "\n# convert a table of OTL format of genus_species_ottXXXX names into standard \"genus species\".  Single names (taxonomy)\n# are passed through without the _ottXXX postpended, as well. \n\ncolname = table['fields'][0]\noutrows = []\nfor row in table['rows']:\n    outrow = {}\n    splitname = row[colname].split('_')\n    if len(splitname) == 3:\n        outname = splitname[0] + ' ' + splitname[1]\n    elif len(splitname) == 2:\n        outname = splitname[0]\n    else:\n        #complex case:  remove last _ottXXX and change to spaces, but leave all components\n        outname = ''\n        for i in range(len(splitname)-1):\n            outname = outname + splitname[i] + ' '\n        # strip off the final space\n        if len(outname)> 1:\n            outname = outname[:-1]\n    outrow[colname] = outname\n    outrows.append(outrow)\n    \nouttable = {}\nouttable['fields'] = [colname]\nouttable['rows'] = outrows\n    \n    "}, "visualization": false, "x": 625, "y": 288}, {"girderId": "590de99f54cdbf2d4cbf0805", "modified": "2017-05-06T16:43:28.269325+00:00", "name": "Compare Tree Tip Lists", "task": {"description": "", "inputs": [{"description": "enumeration of tree tips in a table:rows structure, assumed 1 column", "format": "rows", "id": "table1", "name": "table1", "type": "table"}, {"description": "Tree tip list for comparison with the first table by this method", "format": "rows", "id": "table2", "name": "table2", "type": "table"}], "mode": "python", "name": "Compare Tree Tip Lists", "outputs": [{"description": "count of entries found only in table1", "format": "text", "id": "table1UniqueCount", "name": "table1UniqueCount", "type": "string"}, {"description": "count of entries found only in table2 (but not in table1)", "format": "text", "id": "table2UniqueCount", "name": "table2UniqueCount", "type": "string"}, {"description": "count of entries found in both tables", "format": "text", "id": "tablesCommonCount", "name": "tablesCommonCount", "type": "string"}], "script": "# tree tips comparision\n# KnowledgeVis, LLC\n# May 2017\n\n# loop through the primary table (table1) and compare with the secondary list (table2) to \n# generate three results:  (1) entries only in table1, (2) entries common to both lists, and (3) entries only in table2\n# The third result is achieved by subtracting result#2 (common elements) from the total length of table2.  \n\n# Performance is not optimized here, but we use a dictionary for the table2, assuming table2 (sometimes the OpenTree case)\n# may be in general longer, so we place table2 content into a dictionary to utilize the efficiency of hash-based lookups.\n\ndebugString = ''\ndict2 = {}\n\n# find the columnname\nt2colname = table2['fields'][0]\n\n# store all entries in table2 as keys in a dictionary to use hashing for lookups. The value doesn't really matter, so \n# just store a boolean value to avoid wasting memory\nfor row in table2['rows']:\n    dict2[row[t2colname]] = True\n    \ntable1OnlyCount = 0\ncommonCount = 0\n#commonList = []\n\nt1colname = table1['fields'][0]\nfor row in table1['rows']:\n    if row[t1colname] in dict2.keys():\n        commonCount += 1\n        #commonList.append(row[t1colname])\n    else:\n        table1OnlyCount += 1\n\n# now that we are done scanning, the table2 only entry count can be calculated\ntable2OnlyCount = len(table2['rows']) - commonCount\n\n# return string values to make it easier to review through Arbor interface\ntable1UniqueCount = str(table1OnlyCount)\ntable2UniqueCount = str(table2OnlyCount)\ntablesCommonCount = str(commonCount)\n\n\n    \n"}, "visualization": false, "x": 831, "y": 136}]}