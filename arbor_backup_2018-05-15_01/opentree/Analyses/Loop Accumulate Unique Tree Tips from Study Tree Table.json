{"description": "", "inputs": [{"format": "rows", "id": "table", "name": "table", "type": "table"}], "mode": "python", "name": "Loop Accumulate Unique Tree Tips from Study Tree Table", "outputs": [{"format": "rows", "id": "accumulatedTips", "name": "accumulatedTips", "type": "table"}, {"description": "size of final table of unique names", "format": "number", "id": "uniqueTipCount", "name": "Unique Tip Count", "type": "number"}, {"description": "count of total number of tips from all tries, even if they are duplicates", "format": "number", "id": "duplicatedTipCount", "name": "Total Tip Count including duplicates", "type": "number"}], "script": "import json\nimport requests\nimport girder_worker\nimport girder_client\n\n# this is a looping method that goes through a study tree table and repeatedly calls a subordinate workflow to retrieve the tree \n# and get its list of tree tips.  First, the subordinate analysis is looked up by name using the Girder Client. \n\ndebugString = ''\n\n#print 'input table:',table\n\n# create instance of the girder client\n#gc = girder_client.GirderClient(apiUrl='http://arbor.arborworkflows.com/girder/api/v1')\ngc = girder_client.GirderClient(apiUrl='http://localhost:8080/girder/api/v1')\n#gc = girder_client.GirderClient('localhost',8080)\n# lookup the analysis in a known location (the opentree collection)\nmethodToLoop = \"WF Tree Tips from Study Tree\"\nmethodSearchResults = gc.resourceLookup('/collection/opentree/Analyses/'+methodToLoop)\nanalysis = methodSearchResults['meta']['analysis']\nprint 'analysis ID:',analysis\n\ndebugString += json.dumps(analysis)\ndebugString += '\\n'\n\n# now we have a JSON description of the analysis method to run inside the loop. Start with an empty output and loop through \n# the input, calling the subordinate method for each row of the input table\n\nduplicatedTips = []\n\nfor row in table['rows']:\n    subinputs = {\n        'studyID': {'format': 'string', 'data': row['ot:studyId']},\n        'treeID': {'format': 'string', 'data': row['ot:treeId']}\n    }\n    # run the analysis\n    #debugString += 'about to run\\n'\n    suboutputs = girder_worker.run(analysis, subinputs,{'result': {'format': 'rows'}})\n    #debugString += 'completed run\\n'\n\n    # get the tips from this tree and output a debug status containing the treename\n    tipsFromOneTree = suboutputs['nametable']['data']\n    debugString += 'tree: '+row['ot:treeId']+'\\n'\n    \n    # add the discovered tips from one tree into a temporary list that will be used to \n    # combine non-unique entries before generating the final output.  We pick out the first\n    # column of the table, regardless of what column header was used\n    for newrow in tipsFromOneTree['rows']:\n        duplicatedTips.append(newrow[tipsFromOneTree['fields'][0]])\n\n# now combine non-unique tips\nuniqueTips = set(duplicatedTips)\n\n# prepare final output datastructure (unique tip table and counts)\naccumulatedTips = {}\naccumulatedTips['fields'] = ['name']\naccumulatedTips['rows'] = []\n\nfor x in uniqueTips:\n    newrow = {}\n    newrow['name'] = x\n    accumulatedTips['rows'].append(newrow)\n\nduplicatedTipCount = len(duplicatedTips)\nuniqueTipCount = len(uniqueTips)\n\n"}