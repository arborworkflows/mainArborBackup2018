{"connections": [{"input": "table", "input_step": "EpochModelBestFit", "name": "table"}, {"input": "column", "input_step": "EpochModelBestFit", "name": "column"}, {"input": "tree", "input_step": "EpochModelBestFit", "name": "tree"}, {"input": "iterations", "input_step": "EpochModelBestFit", "name": "iterations"}, {"input": "optimizationMethods", "input_step": "EpochModelBestFit", "name": "optimizationMethods"}, {"input": "table", "input_step": "selectColumnsFromTable", "output": "bestFit", "output_step": "EpochModelBestFit"}, {"input": "columns", "input_step": "selectColumnsFromTable", "name": "oolumns"}, {"name": "bestFit", "output": "bestFit", "output_step": "EpochModelBestFit"}, {"input": "tree", "input_step": "EpochModelASR", "output": "phy", "output_step": "EpochModelBestFit"}, {"input": "column", "input_step": "EpochModelASR", "name": "column"}, {"input": "modelParameters", "input_step": "EpochModelASR", "output": "outTable", "output_step": "selectColumnsFromTable"}, {"input": "table", "input_step": "EpochModelASR", "output": "dat", "output_step": "EpochModelBestFit"}, {"name": "asrPlot", "output": "asrPlot", "output_step": "EpochModelASR"}, {"name": "ASR", "output": "ASR", "output_step": "EpochModelASR"}, {"input": "table", "input_step": "EpochModelLikelihoodProfile", "name": "table"}, {"input": "tree", "input_step": "EpochModelLikelihoodProfile", "name": "tree"}, {"input": "steps", "input_step": "EpochModelLikelihoodProfile", "name": "steps"}, {"input": "column", "input_step": "EpochModelLikelihoodProfile", "name": "column"}, {"name": "Profile table", "output": "profres", "output_step": "EpochModelLikelihoodProfile"}, {"name": "lnLPlot", "output": "lnLPlot", "output_step": "EpochModelLikelihoodProfile"}], "description": "", "inputs": [{"description": "A data table", "format": "r.dataframe", "id": "table", "name": "table", "type": "table", "x": -3, "y": -2}, {"description": "The trait to fit to the model", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string", "x": 1, "y": 104}, {"description": "A phylogenetic tree", "format": "r.apetree", "id": "tree", "name": "tree", "type": "tree", "x": 2, "y": 207}, {"default": {"data": "8", "format": "text", "type": "string"}, "description": "The number of optimizations to run (from different starting points)", "format": "number", "id": "iterations", "name": "iterations", "type": "number", "x": 5, "y": 310}, {"default": {"data": "nlminb, bobyqa", "format": "text", "type": "string"}, "description": "The method(s) used to optimize the models ( 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin')", "format": "text", "id": "optimizationMethods", "name": "optimizationMethods", "type": "string", "x": 8, "y": 414}, {"constant": true, "default": {"data": "2:6", "format": "text", "type": "string"}, "description": "A string of column names or numbers to select (e.g. '1:5, 7, 9' or 'colname1, colname2, colname7')", "format": "text", "id": "oolumns", "name": "oolumns", "type": "string", "x": 257, "y": 40}, {"constant": true, "default": {"data": "10", "format": "text", "type": "string"}, "description": "The number of intervals along the tree length to calculate the likelihood.", "format": "number", "id": "steps", "name": "steps", "type": "number", "x": 6, "y": 517}], "mode": "workflow", "name": "EpochModels", "outputs": [{"description": "A table summarizing best-fitting epoch model", "format": "r.dataframe", "id": "bestFit", "name": "bestFit", "type": "table", "x": 1071, "y": 339}, {"description": "An image of the reconstructed ancestral states on the phylogeny.", "format": "png.base64", "id": "asrPlot", "name": "asrPlot", "type": "image", "x": 1056, "y": 38}, {"description": "A table of reconstructed ancestral state probabilities for each node (in order as specified in ape's edge matrix)", "format": "r.dataframe", "id": "ASR", "name": "ASR", "type": "table", "x": 1052, "y": 190}, {"description": "Profile fits", "format": "r.dataframe", "id": "Profile table", "name": "Profile table", "type": "table", "x": 1070, "y": 457}, {"description": "A plot showing the likelihood profile for different shift points across the phylogeny", "format": "png.base64", "id": "lnLPlot", "name": "lnLPlot", "type": "image", "x": 1070, "y": 572}], "steps": [{"girderId": "5779a55a4c46530689f552f5", "modified": "2016-07-04 10:05:05.289000", "name": "EpochModelBestFit", "task": {"description": "This function finds the best fitting epoch model for a binary trait selected from a table", "inputs": [{"description": "A data table", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "The trait to fit to the model", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string"}, {"description": "A phylogenetic tree", "format": "r.apetree", "id": "tree", "name": "tree", "type": "tree"}, {"default": {"data": "8", "format": "text", "type": "string"}, "description": "The number of optimizations to run (from different starting points)", "format": "number", "id": "iterations", "name": "iterations", "type": "number"}, {"default": {"data": "nlminb, bobyqa", "format": "text", "type": "string"}, "description": "The method(s) used to optimize the models ( 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin')", "format": "text", "id": "optimizationMethods", "name": "optimizationMethods", "type": "string"}], "mode": "r", "name": "EpochModelBestFit", "outputs": [{"description": "A table summarizing best-fitting epoch model", "format": "r.dataframe", "id": "bestFit", "name": "bestFit", "type": "table"}, {"description": "Tree used to analyze the data, matched to the data with NAs removed", "format": "r.apetree", "id": "phy", "name": "phy", "type": "tree"}, {"description": "Trait data used in the analysis, matched to the tree with NAs removed", "format": "r.dataframe", "name": "dat", "type": "table"}], "script": "require(treeplyr)\nrequire(diversitree)\nrequire(cardoonTools)\nrequire(foreach)\nrequire(optimx)\n\n\n## modified diversitree functions for analyzing epoch models\nconstrain.parse2 <- function (formula, names.lhs, names.rhs, extra = NULL) {\n  formula <- as.formula(formula)\n  if (length(formula) != 3L) \n    stop(\"Invalid formula\")\n  lhs <- formula[[2]]\n  rhs <- formula[[3]]\n  if (!is.name(lhs)) \n    stop(\"Invalid target on LHS of formula\")\n  lhs.is.target <- is.na(match(as.character(lhs), names.lhs))\n  if (is.language(rhs)) {\n    vars <- all.vars(rhs)\n    ok <- (all(vars %in% names.rhs) || length(vars) == 1 && vars %in% extra)\n    if (!ok && length(vars) == 1) {\n      e <- parent.frame()\n      if (exists(vars, e)) {\n        rhs <- get(vars, e)\n        ok <- TRUE\n      }\n    }\n    if (!ok && length(vars) > 1){\n      ok <- TRUE\n    }\n    if (!ok) \n      stop(\"Invalid RHS of formula:\\n\\t\", as.character(rhs))\n    if (as.character(lhs) %in% vars) \n      stop(\"LHS cannot appear in RHS\")\n  }\n  else if (!is.numeric(rhs)) {\n    stop(\"RHS must be expression, variable or number\")\n  }\n  res <- list(lhs, rhs)\n  attr(res, \"lhs.is.target\") <- lhs.is.target\n  res\n}\nconstrain2 <- function (f, ..., formulae = NULL, names = argnames(f), extra = NULL) {\n  if (diversitree:::is.constrained(f)) {\n    formulae <- c(attr(f, \"formulae\"), formulae)\n    f <- attr(f, \"func\")\n  }\n  formulae <- c(formulae, list(...))\n  names.lhs <- names.rhs <- names\n  rels <- list()\n  for (formula in formulae) {\n    res <- constrain.parse2(formula, names.lhs, names.rhs, extra)\n    if (attr(res, \"lhs.is.target\")) {\n      i <- try(which(sapply(rels, function(x) identical(x, \n                                                        res[[1]]))), silent = TRUE)\n      if (inherits(i, \"try-error\")) \n        stop(sprintf(\"Error parsing constraint with %s on lhs\", \n                     as.character(res[[1]])))\n      rels[i] <- res[[2]]\n      lhs.txt <- as.character(res[[1]])\n      if (any(sapply(rels, function(x) lhs.txt %in% all.vars(x)))) \n        stop(sprintf(\"lhs (%s) is in an expression and can't be constrained\", \n                     lhs.txt))\n    }\n    names.lhs <- setdiff(names.lhs, unlist(lapply(res, all.vars)))\n    names.rhs <- setdiff(names.rhs, as.character(res[[1]]))\n    rels <- c(rels, structure(res[2], names = as.character(res[[1]])))\n  }\n  final <- c(extra, names.rhs)\n  npar <- length(final)\n  free <- setdiff(names.rhs, names(rels))\n  free.i <- match(free, names)\n  free.j <- match(free, final)\n  target.i <- match(names(rels), names)\n  pars.out <- rep(NA, length(names))\n  names(pars.out) <- names\n  g <- function(pars, ..., pars.only = FALSE) {\n    if (length(pars) != npar) \n      stop(sprintf(\"Incorrect parameter length: expected %d, got %d\", \n                   npar, length(pars)))\n    pars.out[free.i] <- pars[free.j]\n    e <- structure(as.list(pars), names = final)\n    pars.out[target.i] <- unlist(lapply(rels, eval, e))\n    if (pars.only) \n      pars.out\n    else f(pars.out, ...)\n  }\n  class(g) <- c(\"constrained\", class(f))\n  attr(g, \"argnames\") <- final\n  attr(g, \"formulae\") <- formulae\n  attr(g, \"extra\") <- extra\n  attr(g, \"func\") <- f\n  g\n}\n\n## Function to make bisse functions\nmake.bisse.fns <- function(td){\n  ## set branch lengths to by\n  #tree$edge.length <- tree$edge.length/1000\n  \n  ## Combine tree \n  tdcy <- td\n  #rownames(tdcy$dat) <- tdcy$phy$tip.label\n  #colnames(tdcy$dat) <- gsub(\"/\", \"_\", colnames(tdcy$dat), fixed=TRUE)\n  nc <- ncol(tdcy$dat)\n  tdcyList <- lapply(1:nc, function(x) select(tdcy, x))\n  #tdcyList <- lapply(1:nc, function(x) filter_(tdcyList[[x]], paste(\"!is.na(\",names(tdcyList[[x]]$dat),\")\", sep=\"\")))\n  \n  ## Set global birth-death parameters\n  bd.lik <- make.bd(tdcy$phy)\n  bd.est <- find.mle(bd.lik, x.init=c(0.1,0))\n  lambda <<- bd.est$par[1]\n  mu <<- bd.est$par[2]\n  \n  ## Make the functions\n  bisse.fns <- lapply(1:nc, function(x) make.bisse.t(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label), functions=c(rep(\"constant.t\",4), rep(\"stepf.t\", 2)))) \n  notime.fns <- lapply(1:nc, function(x) make.bisse(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label)))\n  ARD.notime.fns <- lapply(notime.fns, function(x) constrain(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu))\n  .ARD.R1.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r*q10.y0, q01.y1~r*q01.y0, q01.tc ~ q10.tc, extra=c('r')))\n  .ARD.R2.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r1*q10.y0, q01.y1~r2*q01.y0, q01.tc ~ q10.tc, extra=c('r1', 'r2')))\n  ARD.R1.fns <- lapply(.ARD.R1.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x); f})\n  ARD.R2.fns <- lapply(.ARD.R2.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x); f})\n  fns <- list(bisse=bisse.fns, notime=notime.fns, ARD.notime=ARD.notime.fns, ARD.R1=ARD.R1.fns, ARD.R2=ARD.R2.fns, tdList=tdcyList)\n  return(fns)\n  \n}\n\n## Make profiles\nprofiles <- function(n, fns, tds, starts, seq=seq(0.1, 0.9, 0.1), cores=1, start4=FALSE){\n  ## Start only over seq1, add seq2 if it looks productive\n  nc <- length(fns)\n  TL <- sum(tds[[1]]$phy$edge.length)\n  nedges <- nrow(tds[[1]]$phy$edge)\n  res <- list()\n  seqFns <- lapply(fns, function(x) lapply(seq, function(y) {ft <<- y; constrain2(x, q10.tc~ft, extra=c(\"r1\", \"r2\"))}))\n  for(i in 1:nc){\n    tmpfns <- seqFns[[i]]\n    tmp <-  parallel::mclapply(1:length(seq), function(j) {\n      fn <- tmpfns[[j]];\n      ft <<- seq[j];\n      #fn <- constrain2(fn, q10.tc~ft, extra=c(\"r1\", \"r2\"))\n      if(start4){\n        startx <- starts[[i]][,1:4];\n        startx[which(startx[,1:2]>=10000)] <- 10000\n        startx[which(startx[,1:2]<=0.01)] <- 0.01+0.0000001\n        startx[which(startx[,3:4]>=0.5*100)] <- 0.5*100-0.1\n        startx[2*nrow(startx)+which(startx[,3:4]<=0.01/100)] <- 0.01/100+0.0000000001\n      } else{\n        startx <- cbind(0, 0, defactor(starts[i, 1]), defactor(starts[i, 2]));\n        startx[which(startx[,3:4]>=10*nedges/TL)] <- 10*nedges/TL\n        startx[2*nrow(startx)+which(startx[,3:4]<=1/TL)] <-1/TL\n      }\n      if(start4) {\n        optimx(startx[j,], fn, method=c(\"nlminb\"), lower=c(log(0.0005),log(0.0005),1/TL, 1/TL), upper=c(log(2000), log(2000), 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      } else {\n        optimx(as.vector(startx), fn, method=c(\"nlminb\"), lower=c(log(0.0005),log(0.0005),1/TL, 1/TL), upper=c(log(2000), log(2000), 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      }\n      #find.mle(fn, x.init=startx, method=\"subplex\")\n    }, mc.preschedule=FALSE, mc.cores=cores)\n    res[[i]] <- tmp\n    rm(tmp)     \n    gc()\n  }\n  res\n}\n\n## Function to fit Fns\nfitFns <- function(n, fns, tds, res=NULL, methods= \"nlminb\"){\n  nc <- length(fns)\n  for(j in 1:n) {\n    fits <- foreach(i=1:nc) %dopar% {\n      optimx(par=start.gen(fns[[i]], tds[[i]]), fns[[i]], method=methods, lower=lower.gen(fns[[i]], tds[[i]]), upper=upper.gen(fns[[i]], tds[[i]]), control=list(maximize=TRUE) )\n    }\n    ## Create a summary table\n    parests <- do.call(rbind, fits)\n    colnames(parests) <- c(argnames(fns[[1]]), \"lnL\", \"fevals\", \"gevals\", \"niter\", \"convcode\", \"kkt1\", \"kkt2\", \"xtimes\")\n    ## Save only the best-fitting indpendent runs\n    if(is.null(res)){\n      res <- parests\n    } else {\n      replace <- which(defactor(parests$lnL) > defactor(res$lnL))\n      if(length(replace) > 0){\n        res[-ncol(res)] <- apply(res[-ncol(res)], 2, defactor)\n        parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        res[replace, ] <- parests[replace, ]\n        #cyFit.best[-ncol(cyFit.best)] <- apply(cyFit.best[-ncol(cyFit.best)], 2, defactor)\n        #parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        #cyFit.best[replace, ] <- parests[replace, ]\n      }\n      print(replace)\n      \n    }\n  }\n  if(sum(colnames(res) %in% c(\"r1\", \"r2\", \"r\")) >0){\n    res[,which(colnames(res) %in% c(\"r\", \"r1\", \"r2\"))] <- exp(res[,which(colnames(res) %in% c(\"r\", \"r1\", \"r2\"))])\n  }\n  res <- dplyr::arrange(res, desc(lnL))\n  return(res)\n}\ndefactor <- function(x){\n  as.numeric(as.character(x))\n}\n\n\n## Function to generate starting parameters\nstart.gen <- function(fn, td){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- runif(length(rs), log(0.0005), log(2000))\n  pars[qs] <- exp(runif(length(qs), log( 1/sum(td$phy$edge.length)), log(nrow(td$phy$edge)*10/sum(td$phy$edge.length))))\n  pars[ts] <- runif(length(ts), 0, TH)\n  pars\n}\nlower.gen <- function(fn, td, ln=FALSE){\n  #TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- log(0.0005)\n  pars[qs] <- 1/sum(td$phy$edge.length)\n  pars[ts] <- 0\n  pars\n}\nupper.gen <- function(fn, td, ln=FALSE){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- log(2000)\n  pars[qs] <- nrow(td$phy$edge)*10/sum(td$phy$edge.length)\n  pars[ts] <- TH\n  pars\n}\ntd <- make.treedata(tree, table)\ntd <- select_(td, column) %>% filter(., !is.na(.[[1]]))\nphy <- td$phy\ndat <- td[[1]]\n\n## Calculate tree height\nTL <- max(branching.times(phy))\n## Rescale tree to 1\ntd$phy$edge.length <- td$phy$edge.length/max(branching.times(phy))\nfns <- make.bisse.fns(td)\n\noptimM <- gsub(\" \", \"\", strsplit(optimizationMethods, \",\")[[1]])\nbestFit <- fitFns(iterations, fns$ARD.R2, fns$tdList, method=optimM)\nbestFit <- data.frame(method=rownames(bestFit), bestFit)\nphy <- td$phy\ndat <- data.frame(tipLabels=td$phy$tip.label, td[,1])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}, "visualization": false, "x": 259, "y": 163}, {"girderId": "577a31d74c46530689f55351", "modified": "2016-07-04 09:55:43.891028", "name": "selectColumnsFromTable", "task": {"description": "", "inputs": [{"description": "A table", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "A string of column names or numbers to select (e.g. '1:5, 7, 9' or 'colname1, colname2, colname7')", "format": "text", "id": "columns", "name": "oolumns", "type": "string"}], "mode": "r", "name": "selectColumnsFromTable", "outputs": [{"description": "An output table with only the selected columns", "format": "r.dataframe", "id": "outTable", "name": "outTable", "type": "table"}], "script": "require(dplyr)\n\ncols <- gsub(\" \", \"\", strsplit(columns, \",\")[[1]])\noutTable <- select_(table, cols)\n"}, "visualization": false, "x": 511, "y": 40}, {"girderId": "577a2f234c46530689f5534f", "modified": "2016-07-04 10:44:59.635303", "name": "EpochModelASR", "task": {"description": "", "inputs": [{"description": "A data table with binary trait data", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "A phylogenetic tree", "format": "r.apetree", "id": "tree", "name": "tree", "type": "tree"}, {"description": "The column from the table with the trait to analyze", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string"}, {"description": "A data table containing the parameters from the model to reconstruct the ancestral states. ", "format": "r.dataframe", "id": "modelParameters", "name": "modelParameters", "type": "table"}], "mode": "r", "name": "EpochModelASR", "outputs": [{"description": "An image of the reconstructed ancestral states on the phylogeny.", "format": "png.base64", "id": "asrPlot", "name": "asrPlot", "type": "image"}, {"description": "A table of reconstructed ancestral state probabilities for each node (in order as specified in ape's edge matrix)", "format": "r.dataframe", "id": "ASR", "name": "ASR", "type": "table"}], "script": "require(treeplyr)\nrequire(diversitree)\nrequire(cardoonTools)\n\n\n## modified diversitree functions for analyzing epoch models\nconstrain.parse2 <- function (formula, names.lhs, names.rhs, extra = NULL) {\n  formula <- as.formula(formula)\n  if (length(formula) != 3L) \n    stop(\"Invalid formula\")\n  lhs <- formula[[2]]\n  rhs <- formula[[3]]\n  if (!is.name(lhs)) \n    stop(\"Invalid target on LHS of formula\")\n  lhs.is.target <- is.na(match(as.character(lhs), names.lhs))\n  if (is.language(rhs)) {\n    vars <- all.vars(rhs)\n    ok <- (all(vars %in% names.rhs) || length(vars) == 1 && vars %in% extra)\n    if (!ok && length(vars) == 1) {\n      e <- parent.frame()\n      if (exists(vars, e)) {\n        rhs <- get(vars, e)\n        ok <- TRUE\n      }\n    }\n    if (!ok && length(vars) > 1){\n      ok <- TRUE\n    }\n    if (!ok) \n      stop(\"Invalid RHS of formula:\\n\\t\", as.character(rhs))\n    if (as.character(lhs) %in% vars) \n      stop(\"LHS cannot appear in RHS\")\n  }\n  else if (!is.numeric(rhs)) {\n    stop(\"RHS must be expression, variable or number\")\n  }\n  res <- list(lhs, rhs)\n  attr(res, \"lhs.is.target\") <- lhs.is.target\n  res\n}\nconstrain2 <- function (f, ..., formulae = NULL, names = argnames(f), extra = NULL) {\n  if (diversitree:::is.constrained(f)) {\n    formulae <- c(attr(f, \"formulae\"), formulae)\n    f <- attr(f, \"func\")\n  }\n  formulae <- c(formulae, list(...))\n  names.lhs <- names.rhs <- names\n  rels <- list()\n  for (formula in formulae) {\n    res <- constrain.parse2(formula, names.lhs, names.rhs, extra)\n    if (attr(res, \"lhs.is.target\")) {\n      i <- try(which(sapply(rels, function(x) identical(x, \n                                                        res[[1]]))), silent = TRUE)\n      if (inherits(i, \"try-error\")) \n        stop(sprintf(\"Error parsing constraint with %s on lhs\", \n                     as.character(res[[1]])))\n      rels[i] <- res[[2]]\n      lhs.txt <- as.character(res[[1]])\n      if (any(sapply(rels, function(x) lhs.txt %in% all.vars(x)))) \n        stop(sprintf(\"lhs (%s) is in an expression and can't be constrained\", \n                     lhs.txt))\n    }\n    names.lhs <- setdiff(names.lhs, unlist(lapply(res, all.vars)))\n    names.rhs <- setdiff(names.rhs, as.character(res[[1]]))\n    rels <- c(rels, structure(res[2], names = as.character(res[[1]])))\n  }\n  final <- c(extra, names.rhs)\n  npar <- length(final)\n  free <- setdiff(names.rhs, names(rels))\n  free.i <- match(free, names)\n  free.j <- match(free, final)\n  target.i <- match(names(rels), names)\n  pars.out <- rep(NA, length(names))\n  names(pars.out) <- names\n  g <- function(pars, ..., pars.only = FALSE) {\n    if (length(pars) != npar) \n      stop(sprintf(\"Incorrect parameter length: expected %d, got %d\", \n                   npar, length(pars)))\n    pars.out[free.i] <- pars[free.j]\n    e <- structure(as.list(pars), names = final)\n    pars.out[target.i] <- unlist(lapply(rels, eval, e))\n    if (pars.only) \n      pars.out\n    else f(pars.out, ...)\n  }\n  class(g) <- c(\"constrained\", class(f))\n  attr(g, \"argnames\") <- final\n  attr(g, \"formulae\") <- formulae\n  attr(g, \"extra\") <- extra\n  attr(g, \"func\") <- f\n  g\n}\n\n## Function to make bisse functions\nmake.bisse.fns <- function(td){\n  ## set branch lengths to by\n  #tree$edge.length <- tree$edge.length/1000\n  \n  ## Combine tree \n  tdcy <- td\n  #rownames(tdcy$dat) <- tdcy$phy$tip.label\n  #colnames(tdcy$dat) <- gsub(\"/\", \"_\", colnames(tdcy$dat), fixed=TRUE)\n  nc <- ncol(tdcy$dat)\n  tdcyList <- lapply(1:nc, function(x) select(tdcy, x))\n  #tdcyList <- lapply(1:nc, function(x) filter_(tdcyList[[x]], paste(\"!is.na(\",names(tdcyList[[x]]$dat),\")\", sep=\"\")))\n  \n  ## Set global birth-death parameters\n  bd.lik <- make.bd(tdcy$phy)\n  bd.est <- find.mle(bd.lik, x.init=c(0.1,0))\n  lambda <<- bd.est$par[1]\n  mu <<- bd.est$par[2]\n  \n  ## Make the functions\n  bisse.fns <- lapply(1:nc, function(x) make.bisse.t(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label), functions=c(rep(\"constant.t\",4), rep(\"stepf.t\", 2)))) \n  notime.fns <- lapply(1:nc, function(x) make.bisse(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label)))\n  ARD.notime.fns <- lapply(notime.fns, function(x) constrain(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu))\n  .ARD.R1.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r*q10.y0, q01.y1~r*q01.y0, q01.tc ~ q10.tc, extra=c('r')))\n  .ARD.R2.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r1*q10.y0, q01.y1~r2*q01.y0, q01.tc ~ q10.tc, extra=c('r1', 'r2')))\n  ARD.R1.fns <- lapply(.ARD.R1.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x);attributes(f)$bisseFn <- x; f})\n  ARD.R2.fns <- lapply(.ARD.R2.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x);attributes(f)$bisseFn <- x; f})\n  fns <- list(bisse=bisse.fns, notime=notime.fns, ARD.notime=ARD.notime.fns, ARD.R1=ARD.R1.fns, ARD.R2=ARD.R2.fns, tdList=tdcyList)\n  return(fns)\n  \n}\n\n\n### Begin analysis code\n### Match tree and data\ntd <- make.treedata(tree, table)\ntd <- select_(td, column) %>% filter(., !is.na(.[[1]]))\nTH <- max(branching.times(td$phy))\n## Rescale tree to 1\ntd$phy$edge.length <- td$phy$edge.length/max(branching.times(td$phy))\n## Create sequence over which to calculate likelihood\nfns <- make.bisse.fns(td)\n\nasr <- asr.marginal(attributes(fns$ARD.R2[[1]])$bisseFn, pars = unlist(modelParameters[1,]))\n\nplotfn <- function() {\n    plot(td$phy, cex=0.25, label.offset = 0.1)\n    nodelabels(pie=t(asr), piecol=c(\"#f1c40f\",\"#e74c3c\"), cex=0.5)\n    tiplabels(pch=21, bg=c(\"#f1c40f\",\"#e74c3c\")[td$dat[[1]]+1], col=c(\"#f1c40f\",\"#e74c3c\")[td$dat[[1]]+1], cex=0.4, adj = c(0.51,0.5))\n    abline(v=modelParameters[1,5], lty=2, lwd=3, col=\"#7f8c8d\")\n    seq1 <- seq(TH,0, length.out=5)\n    seq2 <- seq(1, 0, length.out=5)\n    axis(1, rev(signif(seq2, 2)), labels=signif(seq1,2), lwd=1)\n    legend(0, 0.15*length(tree$tip.label), legend=c(0,1), pch=21, pt.bg=c(\"#f1c40f\",\"#e74c3c\"))\n}\n\nASR <- t(asr)\n\nasrPlot <- cardoonPlot(expression(plotfn()), width=1000, height=1000, res=100)\nasrPlot <- asrPlot$png\n\n\n\n\n\n\n"}, "visualization": false, "x": 817, "y": 124}, {"girderId": "5778a6bd4c46530689f551e9", "modified": "2016-07-04 10:56:03.194000", "name": "EpochModelLikelihoodProfile", "task": {"description": "This R function constructs a likelihood profile plot for discrete epoch model fits.", "inputs": [{"description": "A data frame with binary trait data", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "A phylogenetic tree", "format": "r.apetree", "id": "tree", "name": "tree", "type": "tree"}, {"default": {"data": "10", "format": "text", "type": "string"}, "description": "The number of intervals along the tree length to calculate the likelihood.", "format": "number", "id": "steps", "name": "steps", "type": "number"}, {"description": "Trait to be analyzed", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string"}], "mode": "r", "name": "EpochModelLikelihoodProfile", "outputs": [{"description": "Profile fits", "format": "r.dataframe", "id": "profres", "name": "Profile table", "type": "table"}, {"description": "A plot showing the likelihood profile for different shift points across the phylogeny", "format": "png.base64", "id": "lnLPlot", "name": "lnLPlot", "type": "image"}], "script": "require(treeplyr)\nrequire(diversitree)\nrequire(cardoonTools)\nrequire(foreach)\nrequire(optimx)\n\n## modified diversitree functions for analyzing epoch models\nconstrain.parse2 <- function (formula, names.lhs, names.rhs, extra = NULL) {\n  formula <- as.formula(formula)\n  if (length(formula) != 3L) \n    stop(\"Invalid formula\")\n  lhs <- formula[[2]]\n  rhs <- formula[[3]]\n  if (!is.name(lhs)) \n    stop(\"Invalid target on LHS of formula\")\n  lhs.is.target <- is.na(match(as.character(lhs), names.lhs))\n  if (is.language(rhs)) {\n    vars <- all.vars(rhs)\n    ok <- (all(vars %in% names.rhs) || length(vars) == 1 && vars %in% extra)\n    if (!ok && length(vars) == 1) {\n      e <- parent.frame()\n      if (exists(vars, e)) {\n        rhs <- get(vars, e)\n        ok <- TRUE\n      }\n    }\n    if (!ok && length(vars) > 1){\n      ok <- TRUE\n    }\n    if (!ok) \n      stop(\"Invalid RHS of formula:\\n\\t\", as.character(rhs))\n    if (as.character(lhs) %in% vars) \n      stop(\"LHS cannot appear in RHS\")\n  }\n  else if (!is.numeric(rhs)) {\n    stop(\"RHS must be expression, variable or number\")\n  }\n  res <- list(lhs, rhs)\n  attr(res, \"lhs.is.target\") <- lhs.is.target\n  res\n}\nconstrain2 <- function (f, ..., formulae = NULL, names = argnames(f), extra = NULL) {\n  if (diversitree:::is.constrained(f)) {\n    formulae <- c(attr(f, \"formulae\"), formulae)\n    f <- attr(f, \"func\")\n  }\n  formulae <- c(formulae, list(...))\n  names.lhs <- names.rhs <- names\n  rels <- list()\n  for (formula in formulae) {\n    res <- constrain.parse2(formula, names.lhs, names.rhs, extra)\n    if (attr(res, \"lhs.is.target\")) {\n      i <- try(which(sapply(rels, function(x) identical(x, \n                                                        res[[1]]))), silent = TRUE)\n      if (inherits(i, \"try-error\")) \n        stop(sprintf(\"Error parsing constraint with %s on lhs\", \n                     as.character(res[[1]])))\n      rels[i] <- res[[2]]\n      lhs.txt <- as.character(res[[1]])\n      if (any(sapply(rels, function(x) lhs.txt %in% all.vars(x)))) \n        stop(sprintf(\"lhs (%s) is in an expression and can't be constrained\", \n                     lhs.txt))\n    }\n    names.lhs <- setdiff(names.lhs, unlist(lapply(res, all.vars)))\n    names.rhs <- setdiff(names.rhs, as.character(res[[1]]))\n    rels <- c(rels, structure(res[2], names = as.character(res[[1]])))\n  }\n  final <- c(extra, names.rhs)\n  npar <- length(final)\n  free <- setdiff(names.rhs, names(rels))\n  free.i <- match(free, names)\n  free.j <- match(free, final)\n  target.i <- match(names(rels), names)\n  pars.out <- rep(NA, length(names))\n  names(pars.out) <- names\n  g <- function(pars, ..., pars.only = FALSE) {\n    if (length(pars) != npar) \n      stop(sprintf(\"Incorrect parameter length: expected %d, got %d\", \n                   npar, length(pars)))\n    pars.out[free.i] <- pars[free.j]\n    e <- structure(as.list(pars), names = final)\n    pars.out[target.i] <- unlist(lapply(rels, eval, e))\n    if (pars.only) \n      pars.out\n    else f(pars.out, ...)\n  }\n  class(g) <- c(\"constrained\", class(f))\n  attr(g, \"argnames\") <- final\n  attr(g, \"formulae\") <- formulae\n  attr(g, \"extra\") <- extra\n  attr(g, \"func\") <- f\n  g\n}\n\n## Function to make bisse functions\nmake.bisse.fns <- function(td){\n  ## set branch lengths to by\n  #tree$edge.length <- tree$edge.length/1000\n  \n  ## Combine tree \n  tdcy <- td\n  #rownames(tdcy$dat) <- tdcy$phy$tip.label\n  #colnames(tdcy$dat) <- gsub(\"/\", \"_\", colnames(tdcy$dat), fixed=TRUE)\n  nc <- ncol(tdcy$dat)\n  tdcyList <- lapply(1:nc, function(x) select(tdcy, x))\n  #tdcyList <- lapply(1:nc, function(x) filter_(tdcyList[[x]], paste(\"!is.na(\",names(tdcyList[[x]]$dat),\")\", sep=\"\")))\n  \n  ## Set global birth-death parameters\n  bd.lik <- make.bd(tdcy$phy)\n  bd.est <- find.mle(bd.lik, x.init=c(0.1,0))\n  lambda <<- bd.est$par[1]\n  mu <<- bd.est$par[2]\n  \n  ## Make the functions\n  bisse.fns <- lapply(1:nc, function(x) make.bisse.t(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label), functions=c(rep(\"constant.t\",4), rep(\"stepf.t\", 2)))) \n  notime.fns <- lapply(1:nc, function(x) make.bisse(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label)))\n  ARD.notime.fns <- lapply(notime.fns, function(x) constrain(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu))\n  ARD.R1.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r*q10.y0, q01.y1~r*q01.y0, q01.tc ~ q10.tc, extra=c('r')))\n  ARD.R2.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r1*q10.y0, q01.y1~r2*q01.y0, q01.tc ~ q10.tc, extra=c('r1', 'r2')))\n  \n  fns <- list(bisse=bisse.fns, notime=notime.fns, ARD.notime=ARD.notime.fns, ARD.R1=ARD.R1.fns, ARD.R2=ARD.R2.fns, tdList=tdcyList)\n  return(fns)\n  \n}\n\n## Make profiles\nprofiles <- function(n, fns, tds, starts, seq=seq(0.1, 0.9, 0.1), cores=1, start4=FALSE){\n  ## Start only over seq1, add seq2 if it looks productive\n  nc <- length(fns)\n  TL <- sum(tds[[1]]$phy$edge.length)\n  nedges <- nrow(tds[[1]]$phy$edge)\n  res <- list()\n  seqFns <- lapply(fns, function(x) lapply(seq, function(y) {ft <<- y; constrain2(x, q10.tc~ft, extra=c(\"r1\", \"r2\"))}))\n  for(i in 1:nc){\n    tmpfns <- seqFns[[i]]\n    tmp <-  parallel::mclapply(1:length(seq), function(j) {\n      fn <- tmpfns[[j]];\n      ft <<- seq[j];\n      #fn <- constrain2(fn, q10.tc~ft, extra=c(\"r1\", \"r2\"))\n      if(start4){\n        startx <- starts[[i]][,1:4];\n        startx[which(startx[,1:2]>=10000)] <- 10000\n        startx[which(startx[,1:2]<=0.01)] <- 0.01+0.0000001\n        startx[which(startx[,3:4]>=0.5*100)] <- 0.5*100-0.1\n        startx[2*nrow(startx)+which(startx[,3:4]<=0.01/100)] <- 0.01/100+0.0000000001\n      } else{\n        startx <- cbind(1, 1, defactor(starts[i, 1]), defactor(starts[i, 2]));\n        startx[which(startx[,3:4]>=10*nedges/TL)] <- 10*nedges/TL\n        startx[2*nrow(startx)+which(startx[,3:4]<=1/TL)] <-1/TL\n      }\n      if(start4) {\n        optimx(startx[j,], fn, method=c(\"nlminb\"), lower=c(0.0005,0.0005,1/TL, 1/TL), upper=c(2000, 2000, 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      } else {\n        optimx(as.vector(startx), fn, method=c(\"nlminb\"), lower=c(0.0005,0.0005,1/TL, 1/TL), upper=c(2000, 2000, 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      }\n      #find.mle(fn, x.init=startx, method=\"subplex\")\n    }, mc.preschedule=FALSE, mc.cores=cores)\n    res[[i]] <- tmp\n    rm(tmp)     \n    gc()\n  }\n    res\n}\n\n## Function to fit Fns\nfitFns <- function(n, fns, tds, res=NULL){\n  nc <- length(fns)\n  for(j in 1:n) {\n    fits <- foreach(i=1:nc) %dopar% {\n      find.mle(fns[[i]], x.init=start.gen(fns[[i]], tds[[i]]), method=\"nlminb\", lower=lower.gen(fns[[i]], tds[[i]]), upper=upper.gen(fns[[i]], tds[[i]]) )\n    }\n    ## Create a summary table\n    parests <- do.call(rbind, lapply(fits, function(x) as.data.frame(matrix(c(x$par, x$lnLik, x$message), nrow=1))))\n    colnames(parests) <- c(argnames(fns[[1]]), \"lnL\", \"message\")\n    ## Save only the best-fitting indpendent runs\n    if(is.null(res)){\n      res <- parests\n    } else {\n      replace <- which(defactor(parests$lnL) > defactor(res$lnL))\n      if(length(replace) > 0){\n        res[-ncol(res)] <- apply(res[-ncol(res)], 2, defactor)\n        parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        res[replace, ] <- parests[replace, ]\n        #cyFit.best[-ncol(cyFit.best)] <- apply(cyFit.best[-ncol(cyFit.best)], 2, defactor)\n        #parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        #cyFit.best[replace, ] <- parests[replace, ]\n      }\n      print(replace)\n      \n    }\n  }\n  return(res)\n}\ndefactor <- function(x){\n  as.numeric(as.character(x))\n}\n\n\n## Function to generate starting parameters\nstart.gen <- function(fn, td){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- exp(runif(length(rs), -5, 5))\n  pars[qs] <- exp(runif(length(qs), -5, 5))\n  pars[ts] <- runif(length(ts), 0, TH)\n  pars\n}\nlower.gen <- function(fn, td, ln=FALSE){\n  #TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- 0.0005\n  pars[qs] <- 1/sum(td$phy$edge.length)\n  pars[ts] <- 0\n  pars\n}\nupper.gen <- function(fn, td, ln=FALSE){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- 2000\n  pars[qs] <- nrow(td$phy$edge)*10/sum(td$phy$edge.length)\n  pars[ts] <- TH\n  pars\n}\ntd <- make.treedata(tree, table)\ntd <- select_(td, column) %>% filter(., !is.na(.[[1]]))\nphy <- td$phy\ndat <- td[[1]]\n  \n## Calculate tree height\nTL <- max(branching.times(phy))\n## Rescale tree to 1\ntd$phy$edge.length <- td$phy$edge.length/max(branching.times(phy))\n## Create sequence over which to calculate likelihood\nseqT <- seq(0, 1, length.out=steps+2)[-c(1, steps+2)]\nfns <- make.bisse.fns(td)\nnotime <- fitFns(5, fns$ARD.notime, fns$tdList, res=NULL)\nprof <- profiles(1, fns$ARD.R2, fns$tdList, starts=notime, seq=seqT, cores=1)\nprofres <- data.frame(time=seqT,do.call(rbind, prof[[1]]))\nplotfn <- function() {\n  res <- c(defactor(notime$lnL), profres$value, defactor(notime$lnL))\n  plot(c(0, seqT*TL, TL), res, type=\"n\", xlab=\"Time\", ylab=\"Likelihood\", main=column, xlim=c(TL,0))\n  abline(h=seq(floor(min(res)), ceiling(max(res)), 1), lty=2, lwd=1.5, col=\"gray80\")\n  lines(c(0, seqT*TL, TL), res, lwd=2, col=\"#2980b9\")\n  points(c(0, seqT*TL, TL), res, pch=21, bg=\"#3498db\")\n}\n\nlnLPlot <- cardoonPlot(expression(plotfn()), width=1000, height=1000, res=100)\nlnLPlot <- lnLPlot$png\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}, "visualization": false, "x": 597, "y": 465}]}