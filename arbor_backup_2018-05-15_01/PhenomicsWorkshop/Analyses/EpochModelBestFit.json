{"description": "This function finds the best fitting epoch model for a binary trait selected from a table", "inputs": [{"description": "A data table", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "The trait to fit to the model", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string"}, {"description": "A phylogenetic tree", "format": "r.apetree", "id": "tree", "name": "tree", "type": "tree"}, {"default": {"data": "8", "format": "text", "type": "string"}, "description": "The number of optimizations to run (from different starting points)", "format": "number", "id": "iterations", "name": "iterations", "type": "number"}, {"default": {"data": "nlminb, bobyqa", "format": "text", "type": "string"}, "description": "The method(s) used to optimize the models ( 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin')", "format": "text", "id": "optimizationMethods", "name": "optimizationMethods", "type": "string"}], "mode": "r", "name": "EpochModelBestFit", "outputs": [{"description": "A table summarizing best-fitting epoch model", "format": "r.dataframe", "id": "bestFit", "name": "bestFit", "type": "table"}, {"description": "Tree used to analyze the data, matched to the data with NAs removed", "format": "r.apetree", "id": "phy", "name": "phy", "type": "tree"}, {"description": "Trait data used in the analysis, matched to the tree with NAs removed", "format": "r.dataframe", "name": "dat", "type": "table"}], "script": "require(treeplyr)\nrequire(diversitree)\nrequire(cardoonTools)\nrequire(foreach)\nrequire(optimx)\n\n\n## modified diversitree functions for analyzing epoch models\nconstrain.parse2 <- function (formula, names.lhs, names.rhs, extra = NULL) {\n  formula <- as.formula(formula)\n  if (length(formula) != 3L) \n    stop(\"Invalid formula\")\n  lhs <- formula[[2]]\n  rhs <- formula[[3]]\n  if (!is.name(lhs)) \n    stop(\"Invalid target on LHS of formula\")\n  lhs.is.target <- is.na(match(as.character(lhs), names.lhs))\n  if (is.language(rhs)) {\n    vars <- all.vars(rhs)\n    ok <- (all(vars %in% names.rhs) || length(vars) == 1 && vars %in% extra)\n    if (!ok && length(vars) == 1) {\n      e <- parent.frame()\n      if (exists(vars, e)) {\n        rhs <- get(vars, e)\n        ok <- TRUE\n      }\n    }\n    if (!ok && length(vars) > 1){\n      ok <- TRUE\n    }\n    if (!ok) \n      stop(\"Invalid RHS of formula:\\n\\t\", as.character(rhs))\n    if (as.character(lhs) %in% vars) \n      stop(\"LHS cannot appear in RHS\")\n  }\n  else if (!is.numeric(rhs)) {\n    stop(\"RHS must be expression, variable or number\")\n  }\n  res <- list(lhs, rhs)\n  attr(res, \"lhs.is.target\") <- lhs.is.target\n  res\n}\nconstrain2 <- function (f, ..., formulae = NULL, names = argnames(f), extra = NULL) {\n  if (diversitree:::is.constrained(f)) {\n    formulae <- c(attr(f, \"formulae\"), formulae)\n    f <- attr(f, \"func\")\n  }\n  formulae <- c(formulae, list(...))\n  names.lhs <- names.rhs <- names\n  rels <- list()\n  for (formula in formulae) {\n    res <- constrain.parse2(formula, names.lhs, names.rhs, extra)\n    if (attr(res, \"lhs.is.target\")) {\n      i <- try(which(sapply(rels, function(x) identical(x, \n                                                        res[[1]]))), silent = TRUE)\n      if (inherits(i, \"try-error\")) \n        stop(sprintf(\"Error parsing constraint with %s on lhs\", \n                     as.character(res[[1]])))\n      rels[i] <- res[[2]]\n      lhs.txt <- as.character(res[[1]])\n      if (any(sapply(rels, function(x) lhs.txt %in% all.vars(x)))) \n        stop(sprintf(\"lhs (%s) is in an expression and can't be constrained\", \n                     lhs.txt))\n    }\n    names.lhs <- setdiff(names.lhs, unlist(lapply(res, all.vars)))\n    names.rhs <- setdiff(names.rhs, as.character(res[[1]]))\n    rels <- c(rels, structure(res[2], names = as.character(res[[1]])))\n  }\n  final <- c(extra, names.rhs)\n  npar <- length(final)\n  free <- setdiff(names.rhs, names(rels))\n  free.i <- match(free, names)\n  free.j <- match(free, final)\n  target.i <- match(names(rels), names)\n  pars.out <- rep(NA, length(names))\n  names(pars.out) <- names\n  g <- function(pars, ..., pars.only = FALSE) {\n    if (length(pars) != npar) \n      stop(sprintf(\"Incorrect parameter length: expected %d, got %d\", \n                   npar, length(pars)))\n    pars.out[free.i] <- pars[free.j]\n    e <- structure(as.list(pars), names = final)\n    pars.out[target.i] <- unlist(lapply(rels, eval, e))\n    if (pars.only) \n      pars.out\n    else f(pars.out, ...)\n  }\n  class(g) <- c(\"constrained\", class(f))\n  attr(g, \"argnames\") <- final\n  attr(g, \"formulae\") <- formulae\n  attr(g, \"extra\") <- extra\n  attr(g, \"func\") <- f\n  g\n}\n\n## Function to make bisse functions\nmake.bisse.fns <- function(td){\n  ## set branch lengths to by\n  #tree$edge.length <- tree$edge.length/1000\n  \n  ## Combine tree \n  tdcy <- td\n  #rownames(tdcy$dat) <- tdcy$phy$tip.label\n  #colnames(tdcy$dat) <- gsub(\"/\", \"_\", colnames(tdcy$dat), fixed=TRUE)\n  nc <- ncol(tdcy$dat)\n  tdcyList <- lapply(1:nc, function(x) select(tdcy, x))\n  #tdcyList <- lapply(1:nc, function(x) filter_(tdcyList[[x]], paste(\"!is.na(\",names(tdcyList[[x]]$dat),\")\", sep=\"\")))\n  \n  ## Set global birth-death parameters\n  bd.lik <- make.bd(tdcy$phy)\n  bd.est <- find.mle(bd.lik, x.init=c(0.1,0))\n  lambda <<- bd.est$par[1]\n  mu <<- bd.est$par[2]\n  \n  ## Make the functions\n  bisse.fns <- lapply(1:nc, function(x) make.bisse.t(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label), functions=c(rep(\"constant.t\",4), rep(\"stepf.t\", 2)))) \n  notime.fns <- lapply(1:nc, function(x) make.bisse(tdcyList[[x]]$phy, setNames(tdcyList[[x]]$dat[[1]], attributes(tdcyList[[x]])$tip.label)))\n  ARD.notime.fns <- lapply(notime.fns, function(x) constrain(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu))\n  .ARD.R1.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r*q10.y0, q01.y1~r*q01.y0, q01.tc ~ q10.tc, extra=c('r')))\n  .ARD.R2.fns <- lapply(bisse.fns, function(x) constrain2(x, lambda0~lambda, lambda1~lambda, mu0~mu, mu1~mu, q10.y1~r1*q10.y0, q01.y1~r2*q01.y0, q01.tc ~ q10.tc, extra=c('r1', 'r2')))\n  ARD.R1.fns <- lapply(.ARD.R1.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x); f})\n  ARD.R2.fns <- lapply(.ARD.R2.fns, function(x){f <- function(pp){pp[1:2] <- exp(pp[1:2]); x(pp)}; attributes(f) <- attributes(x); f})\n  fns <- list(bisse=bisse.fns, notime=notime.fns, ARD.notime=ARD.notime.fns, ARD.R1=ARD.R1.fns, ARD.R2=ARD.R2.fns, tdList=tdcyList)\n  return(fns)\n  \n}\n\n## Make profiles\nprofiles <- function(n, fns, tds, starts, seq=seq(0.1, 0.9, 0.1), cores=1, start4=FALSE){\n  ## Start only over seq1, add seq2 if it looks productive\n  nc <- length(fns)\n  TL <- sum(tds[[1]]$phy$edge.length)\n  nedges <- nrow(tds[[1]]$phy$edge)\n  res <- list()\n  seqFns <- lapply(fns, function(x) lapply(seq, function(y) {ft <<- y; constrain2(x, q10.tc~ft, extra=c(\"r1\", \"r2\"))}))\n  for(i in 1:nc){\n    tmpfns <- seqFns[[i]]\n    tmp <-  parallel::mclapply(1:length(seq), function(j) {\n      fn <- tmpfns[[j]];\n      ft <<- seq[j];\n      #fn <- constrain2(fn, q10.tc~ft, extra=c(\"r1\", \"r2\"))\n      if(start4){\n        startx <- starts[[i]][,1:4];\n        startx[which(startx[,1:2]>=10000)] <- 10000\n        startx[which(startx[,1:2]<=0.01)] <- 0.01+0.0000001\n        startx[which(startx[,3:4]>=0.5*100)] <- 0.5*100-0.1\n        startx[2*nrow(startx)+which(startx[,3:4]<=0.01/100)] <- 0.01/100+0.0000000001\n      } else{\n        startx <- cbind(0, 0, defactor(starts[i, 1]), defactor(starts[i, 2]));\n        startx[which(startx[,3:4]>=10*nedges/TL)] <- 10*nedges/TL\n        startx[2*nrow(startx)+which(startx[,3:4]<=1/TL)] <-1/TL\n      }\n      if(start4) {\n        optimx(startx[j,], fn, method=c(\"nlminb\"), lower=c(log(0.0005),log(0.0005),1/TL, 1/TL), upper=c(log(2000), log(2000), 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      } else {\n        optimx(as.vector(startx), fn, method=c(\"nlminb\"), lower=c(log(0.0005),log(0.0005),1/TL, 1/TL), upper=c(log(2000), log(2000), 10*nedges/TL, 10*nedges/TL), control=list(maximize=TRUE))\n      }\n      #find.mle(fn, x.init=startx, method=\"subplex\")\n    }, mc.preschedule=FALSE, mc.cores=cores)\n    res[[i]] <- tmp\n    rm(tmp)     \n    gc()\n  }\n  res\n}\n\n## Function to fit Fns\nfitFns <- function(n, fns, tds, res=NULL, methods= \"nlminb\"){\n  nc <- length(fns)\n  for(j in 1:n) {\n    fits <- foreach(i=1:nc) %dopar% {\n      optimx(par=start.gen(fns[[i]], tds[[i]]), fns[[i]], method=methods, lower=lower.gen(fns[[i]], tds[[i]]), upper=upper.gen(fns[[i]], tds[[i]]), control=list(maximize=TRUE) )\n    }\n    ## Create a summary table\n    parests <- do.call(rbind, fits)\n    colnames(parests) <- c(argnames(fns[[1]]), \"lnL\", \"fevals\", \"gevals\", \"niter\", \"convcode\", \"kkt1\", \"kkt2\", \"xtimes\")\n    ## Save only the best-fitting indpendent runs\n    if(is.null(res)){\n      res <- parests\n    } else {\n      replace <- which(defactor(parests$lnL) > defactor(res$lnL))\n      if(length(replace) > 0){\n        res[-ncol(res)] <- apply(res[-ncol(res)], 2, defactor)\n        parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        res[replace, ] <- parests[replace, ]\n        #cyFit.best[-ncol(cyFit.best)] <- apply(cyFit.best[-ncol(cyFit.best)], 2, defactor)\n        #parests[-ncol(parests)] <- apply(parests[-ncol(parests)], 2, defactor)\n        #cyFit.best[replace, ] <- parests[replace, ]\n      }\n      print(replace)\n      \n    }\n  }\n  if(sum(colnames(res) %in% c(\"r1\", \"r2\", \"r\")) >0){\n    res[,which(colnames(res) %in% c(\"r\", \"r1\", \"r2\"))] <- exp(res[,which(colnames(res) %in% c(\"r\", \"r1\", \"r2\"))])\n  }\n  res <- dplyr::arrange(res, desc(lnL))\n  return(res)\n}\ndefactor <- function(x){\n  as.numeric(as.character(x))\n}\n\n\n## Function to generate starting parameters\nstart.gen <- function(fn, td){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- runif(length(rs), log(0.0005), log(2000))\n  pars[qs] <- exp(runif(length(qs), log( 1/sum(td$phy$edge.length)), log(nrow(td$phy$edge)*10/sum(td$phy$edge.length))))\n  pars[ts] <- runif(length(ts), 0, TH)\n  pars\n}\nlower.gen <- function(fn, td, ln=FALSE){\n  #TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- log(0.0005)\n  pars[qs] <- 1/sum(td$phy$edge.length)\n  pars[ts] <- 0\n  pars\n}\nupper.gen <- function(fn, td, ln=FALSE){\n  TH <- max(branching.times(td$phy))\n  arg <- argnames(fn)\n  rs <- grep(\"r\", arg)\n  qs <- grep(\"q\", arg)\n  ts <- grep(\"t\", arg)\n  qs <- qs[!(qs %in% ts)]\n  pars <- rep(0, length(arg))\n  pars[rs] <- log(2000)\n  pars[qs] <- nrow(td$phy$edge)*10/sum(td$phy$edge.length)\n  pars[ts] <- TH\n  pars\n}\ntd <- make.treedata(tree, table)\ntd <- select_(td, column) %>% filter(., !is.na(.[[1]]))\nphy <- td$phy\ndat <- td[[1]]\n\n## Calculate tree height\nTL <- max(branching.times(phy))\n## Rescale tree to 1\ntd$phy$edge.length <- td$phy$edge.length/max(branching.times(phy))\nfns <- make.bisse.fns(td)\n\noptimM <- gsub(\" \", \"\", strsplit(optimizationMethods, \",\")[[1]])\nbestFit <- fitFns(iterations, fns$ARD.R2, fns$tdList, method=optimM)\nbestFit <- data.frame(method=rownames(bestFit), bestFit)\nphy <- td$phy\ndat <- data.frame(tipLabels=td$phy$tip.label, td[,1])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}