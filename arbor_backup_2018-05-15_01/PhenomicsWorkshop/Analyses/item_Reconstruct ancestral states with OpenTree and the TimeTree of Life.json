{"_id": "577b691854cdbf3c14cc45de", "_modelType": "item", "baseParentId": "577b68e754cdbf3c14cc45d9", "baseParentType": "collection", "created": "2016-07-05T08:00:24.835000+00:00", "creatorId": "5761b37954cdbf3c14cc45bc", "description": "", "folderId": "577b68e754cdbf3c14cc45da", "meta": {"analysis": {"connections": [{"input": "table", "input_step": "Convert underscores to spaces", "name": "table"}, {"input": "table", "input_step": "Match taxa to the TimeTree of Life", "output": "tableOut", "output_step": "Convert underscores to spaces"}, {"input": "column", "input_step": "Match taxa to the TimeTree of Life", "name": "column"}, {"input": "times", "input_step": "Match taxa to the TimeTree of Life", "name": "times"}, {"input": "ncores", "input_step": "Match taxa to the TimeTree of Life", "name": "ncores"}, {"input": "tree", "input_step": "aceArbor", "output": "newTimetree", "output_step": "Match taxa to the TimeTree of Life"}, {"input": "table", "input_step": "aceArbor", "name": "table"}, {"name": "OpenTree TNRS Table", "output": "ottTNRS", "output_step": "Match taxa to the TimeTree of Life"}, {"input": "column", "input_step": "aceArbor", "name": "column 1"}, {"name": "res", "output": "res", "output_step": "aceArbor"}, {"name": "treePlot", "output": "treePlot", "output_step": "aceArbor"}, {"input": "type", "input_step": "aceArbor", "name": "type"}, {"input": "method", "input_step": "aceArbor", "name": "method"}, {"name": "newTimetree", "output": "newTimetree", "output_step": "Match taxa to the TimeTree of Life"}, {"name": "treePlot 1", "output": "treePlot", "output_step": "Match taxa to the TimeTree of Life"}], "description": "", "inputs": [{"description": "input table with underscores in species names", "format": "rows", "id": "table", "name": "Data Table", "type": "table", "x": 53, "y": 53}, {"description": "The column of the data table containing species names", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "Taxonomic Name Column", "type": "string", "x": 51, "y": 163}, {"default": {"data": "2039, 2000, 1000, 750, 600, 500, 400, 350, 300,275, 250,225, 200,175, 150, 125, 100, 75, 50, 40, 30, 20, 10, 5, 2, 1", "format": "text", "type": "string"}, "description": "A string of comma separated values that give the time slices for building a taxonomy in MYBP. All numbers must be between 2040 and 0.", "format": "text", "id": "times", "name": "Timeslices for contructing artificial taxonomy", "type": "string", "x": 47, "y": 272}, {"default": {"data": "1", "format": "text", "type": "string"}, "description": "The number of cores to use for querying OpenTree of life Taxonomic Name Resolution Service", "format": "number", "id": "ncores", "name": "Number of cores", "type": "number", "x": 47, "y": 380}, {"default": "island", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column 1", "name": "Trait Columng", "type": "string", "x": 455, "y": 323}, {"default": "discrete", "domain": ["discrete", "continuous"], "format": "text", "id": "type", "name": "Trait Type", "type": "string", "x": 455, "y": 440}, {"default": "marginal", "domain": ["marginal"], "format": "text", "id": "method", "name": "Reconstruction Method", "type": "string", "x": 456, "y": 559}], "mode": "workflow", "name": "Reconstruct ancestral states with OpenTree and the TimeTree of Life", "outputs": [{"description": "A table providing the TNRS results from OpenTree. Should be checked to determine if the correct taxa were matched to the OpenTree Taxonomy.", "format": "r.dataframe", "id": "OpenTree TNRS Table", "name": "OpenTree TNRS Table", "type": "table", "x": 1260, "y": 343}, {"format": "r.dataframe", "id": "res", "name": "Ancestral States", "type": "table", "x": 1254, "y": 47}, {"format": "png.base64", "id": "treePlot", "name": "Ancestral State Reconstruction Plot", "type": "image", "x": 1258, "y": 198}, {"description": "The resulting time-calibrated phylogeny", "format": "r.apetree", "id": "newTimetree", "name": "new Chronogram", "type": "tree", "x": 1264, "y": 459}, {"description": "Time scaled phylogeny plot", "format": "png.base64", "id": "treePlot 1", "name": "Chronogram with scale bar", "type": "image", "x": 1263, "y": 602}], "steps": [{"girderId": "56c1f7c8e41f69033b110421", "modified": "2016-02-15 16:07:36.518000", "name": "Convert underscores to spaces", "task": {"inputs": [{"description": "input table with underscores in species names", "format": "rows", "name": "table", "type": "table"}], "mode": "python", "name": "Convert underscores to spaces", "outputs": [{"description": "same as input table but name and species columns have replaced underscores", "format": "rows", "name": "tableOut", "type": "table"}], "script": "# input: table - table:rows type representing a trait matrix, with \"species\" or \"name\" as the species column header.  \n# output: tableOut - same table with substituted names  \n\n# this routine replaces underscores in species names with spaces.  E.g.  \"heliconia_robusta\" becomes \"heliconia robusta\".\n\ncolumnNames = table['fields']\noutrows = []\n\n# go through the rows and change underscores to spaces for name and species columns.  output is accumulated in outrows\nfor i in range(len(table['rows'])):\n    row = table['rows'][i]\n    if 'name' in row.keys():\n        newname = row['name'].replace('_',' ')\n        row['name'] = newname\n    elif 'species' in row.keys():\n        newname = row['species'].replace('_',' ')\n        row['species'] = newname\n    outrows.append(row)\n\n# compose output object\ntableOut = {}\ntableOut['fields'] = columnNames\ntableOut['rows'] = outrows\n\n\n    \n        "}, "visualization": false, "x": 334, "y": 50}, {"girderId": "56c4c9974c465302fc340f61", "modified": "2016-02-21 23:51:39.340000", "name": "Match taxa to the TimeTree of Life", "task": {"description": "This function takes a list of taxa and matches them to the OpenTree of life taxonomy. It then matches these taxa to the TimeTree of Life using taxonomy, and swaps out as many exchangeable taxa as possible using the Phyndr algorithm to obtain a time-calibrated phylogeny with maximal overlap with the original taxa list.", "inputs": [{"description": "A data table with a column containing species names to match to the TTOL", "format": "r.dataframe", "id": "table", "name": "table", "type": "table"}, {"description": "The column of the data table containing species names", "domain": {"format": "column.names", "input": "table"}, "format": "text", "id": "column", "name": "column", "type": "string"}, {"default": {"data": "2039, 2000, 1000, 750, 600, 500, 400, 350, 300,275, 250,225, 200,175, 150, 125, 100, 75, 50, 40, 30, 20, 10, 5, 2, 1", "format": "text", "type": "string"}, "description": "A string of comma separated values that give the time slices for building a taxonomy in MYBP. All numbers must be between 2040 and 0.", "format": "text", "id": "times", "name": "times", "type": "string"}, {"default": {"data": "1", "format": "text", "type": "string"}, "description": "The number of cores to use for querying OpenTree of life Taxonomic Name Resolution Service", "format": "number", "id": "ncores", "name": "ncores", "type": "number"}], "mode": "r", "name": "Match taxa to the TimeTree of Life", "outputs": [{"description": "The resulting time-calibrated phylogeny", "format": "r.apetree", "id": "newTimetree", "name": "newTimetree", "type": "tree"}, {"description": "Time scaled phylogeny plot", "format": "png.base64", "id": "treePlot", "name": "treePlot", "type": "image"}, {"description": "A table providing the TNRS results from OpenTree. Should be checked to determine if the correct taxa were matched to the OpenTree Taxonomy.", "format": "r.dataframe", "id": "ottTNRS", "name": "OpenTree TNRS Table", "type": "table"}], "script": "require(treetimer)\nrequire(cardoonTools)\n\n## # Load data from the timetree of life\n## All the different subsets in the future. For now:\ndata(ttolData)\n\ntaxalist <- table[,column]\n\ntimeslices <- sort(as.numeric(gsub(\" \", \"\", strsplit(times, \",\")[[1]])), decreasing=TRUE)\nttPhynd <- phyndrTTOL(ttolData, taxalist, timeslices, prune=TRUE, ncores=ncores)\nnewTimetree <- phyndr_sample(ttPhynd$phyndr)\n\nplotfn <- function() {\n    plot(newTimetree, label.offset = 50, y.lim = c(-1, length(newTimetree$tip.label)))\n    TH <- max(branching.times(newTimetree))\n    seq1 <- seq(TH,0, length.out=5)\n    axis(1, rev(signif(seq1, 2)), labels=signif(seq1,2), lwd=1)\n    }\n    \nottTNRS <- ttPhynd$otts\n    \ntreePlot <- cardoonPlot(expression(plotfn()), width=1000, height=1000, res=100)\ntreePlot <- treePlot$png\n    "}, "visualization": false, "x": 639, "y": 112}, {"girderId": "56bd346c49c5c44cc4a7bbed", "modified": "2016-02-25 06:56:30.771000", "name": "aceArbor", "task": {"description": "", "inputs": [{"description": "A Phylogenetic Tree", "format": "r.apetree", "name": "tree", "type": "tree"}, {"format": "r.dataframe", "name": "table", "type": "table"}, {"default": "island", "domain": {"format": "column.names", "input": "table"}, "format": "text", "name": "column", "type": "string"}, {"default": "discrete", "domain": ["discrete", "continuous"], "format": "text", "name": "type", "type": "string"}, {"default": "marginal", "domain": ["marginal"], "format": "text", "name": "method", "type": "string"}], "mode": "r", "name": "aceArbor", "outputs": [{"format": "r.dataframe", "name": "res", "type": "table"}, {"format": "png.base64", "name": "treePlot", "type": "image"}], "script": "library(devtools)\nlibrary(cardoonTools)\n#options(repos=\"http://cran.cnr.Berkeley.edu\")\n#install.packages(\"diversitree\", type=\"source\")\n#install_github(\"arborworkflows/aRbor\")\n\n\n# Removed this parameter to restore automated use of the analyses from Easy Mode apps\nfont_size <- 1\n\n# Two separate R operations are performed, depending on whether the character is discrete or\n# continuous.  The discrete path uses picante and geiger, while the continuous path uses aRbor.\n\n#if(type==\"discrete\"){\n#    require(picante)\n#    require(geiger)\n#    tree<-as.phylo(tree)\n#    row.names(table)<-table[[1]]\n#    combined<-match.phylo.data(tree, table)\n#    phy<-combined$phy\n#    data<-combined$data\n#    phy$edge.length <- phy$edge.length + 0.000001\n#    trait<-data[[column]]\n#    trait<-as.factor(trait)\n#    res<-ace(trait,phy,type=\"discrete\")\n#    TH <- max(branching.times(phy))\n#    acePlot<-function(phy,res,trait){\n#     cols<-rainbow(nlevels(trait))\n#     plot(phy, type=\"p\", FALSE, cex=1, label.offset=0.8, main=column)\n#     tiplabels(pch=21, bg=cols[as.numeric(trait)], cex=2)\n#     nodelabels(pie = res$lik.anc, piecol=cols, cex=0.5)\n#    }\n\n    # plot and wrap the result in a PNG for output on the webpage\n    # this uses the plot routine defined directly above\n#    treePlot <- cardoonPlot(expression(acePlot(phy, res,trait)), width=1000, height=1000, res=100)\n#    treePlot <- treePlot$png\n    # the return from APE is a complex object, lets pick out a simple table from this to return so it\n    # can be converted to a dataframe reliably\n#    res <- res$lik.anc\n#} \n\n#if(type==\"continuous\"){\n    require(aRbor)\n    td <- make.treedata(tree, table)\n    td1 <- select_(td, column)\n    TH <- max(branching.times(td$phy))\n    td1$phy$edge.length <- td1$phy$edge.length/TH\n    res <- aceArbor(td1, charType=type, aceType=method)\n    # plot and wrap the result in a PNG for output on the webpage\n    treePlot <- cardoonPlot(expression(plot(res, label.offset=0.05*1)), width=1000, height=1000, res=100)\n    treePlot <- treePlot$png\n    \n    #require(picante)\n    #require(geiger)    \n    #tree<-as.phylo(tree)\n    #row.names(table)<-table[[1]]\n    #combined<-match.phylo.data(tree, table)\n    #phy<-combined$phy\n    #data<-combined$data\n    #phy$edge.length <- phy$edge.length + 0.000001\n    #trait<-data[[column]]\n    #trait<-as.numeric(as.character(trait))\n    #standard<-trait-min(trait)\n    #standard<-100*standard/max(standard)\n    #standard<-round(standard,0)\n    #res<-ace(trait,phy,type=\"continuous\")\n    #stdAce<-res$ace-min(res$ace)\n    #stdAce<-100*stdAce/max(stdAce)\n    #stdAce<-round(stdAce,0)\n    #aceContinuousPlot<-function(phy, trait, stdAce, ...){\n    #  cols<-rainbow(100)\n    #  plot(phy, type=\"p\", FALSE, cex=0.5, label.offset=1, main=column)\n    #  tiplabels(pch=21, bg=cols[standard], cex=1, adj=1)\n    #  nodelabels(pch=21, bg=cols[stdAce], cex=1)\n    #}\n    #treePlot <- cardoonPlot(expression(aceContinuousPlot(phy, standard, stdAce)), width=1000, height=1000, res=100)\n    #treePlot <- treePlot$png\n#}\n\n"}, "visualization": false, "x": 956, "y": 58}]}}, "name": "Reconstruct ancestral states with OpenTree and the TimeTree of Life", "size": 0, "updated": "2016-07-05T08:00:25.069000+00:00"}