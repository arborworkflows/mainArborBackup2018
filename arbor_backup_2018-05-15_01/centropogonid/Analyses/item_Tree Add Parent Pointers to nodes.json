{"_id": "5a88665b54cdbf077f6de512", "_modelType": "item", "baseParentId": "5a6f778d54cdbf077f6de37f", "baseParentType": "collection", "created": "2018-02-17T17:28:59.333000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "5a6f778e54cdbf077f6de381", "meta": {"analysis": {"description": "This method assumes a tree (in nested format) and traverses it.  The method adds unique IDs for each node and a parent pointer to show the number of the parent node. The parent fields are needed for Vega to render the trees properly. ", "inputs": [{"description": "tree in nested - data will be added to taxon nodes", "format": "nested", "name": "tree", "type": "tree"}], "mode": "python", "name": "Tree Add Parent Pointers to nodes", "outputs": [{"description": "tree with parent pointers added to the node records", "format": "nested", "name": "treeWithParents", "type": "tree"}], "script": "#  Phylotree and species occurrence matching analysis\n#  Curtis Lisle\n#  KnowledgeVis, LLC\n\n# Copyright by KnowledgeVis,LLC and Kitware, Inc.\n\n# This analysis step scans through a species occurence table (of the format of Chodon's Heliconia location table) and tries to \n# add as many of these location observations as possible to the taxa of an input phylogenetic tree.  Species name and collection number\n# are used to try to find matches.  The output tree has the locations added as attributes so they can be traversed using phyloTraitMap \n# and support interactive exploration. \n\n# Update History:\n# 10/16/14 - added collection/accession number match column input option (previously hard coded to \"Numb\").  Incorporated unique\n#            nodeids so separate analysis step is not required.\n# 03/20/15 CRL - adapted for Costus dataset\n# 07/24/17 CRL - adapted for Calochortus\n#\n\n# NOTE: it has been observed with the Heliconia dataset (2014) that occurrences appear to match more than one taxon, because\n# total matches discovered can be greater than the number of occurrence entries. \n\n# inputs\n# ------\n\n# tree - tree we want to merge the occurrences into (nested format)\n#\n# outputs\n# -------\n# treeWithParents - nested format tree with location arrays added to the taxa\n\ncount = 0\n\nstatusTable = {}\nstatusTable['fields'] = ['description','value']\nstatusTable['rows'] = []\n\n# have a counter for unique nodeIDs.  the nodes only have to be unique within\n# this tree, so a counter can be used. Initialize with count=1\nnodecount = 1\n\ndebug = ''\n    \n\n# this routine traverses a phylo tree in nested format. Add a nodeid and then\n# increment the count every time we encounter a node during a depth first search\n\ndef addUniqueIDsToTreeNodes(treenode):\n    global nodecount\n    if 'nodeid' not in treenode['node_data']:\n        treenode['node_data']['nodeid'] = nodecount\n        nodecount += 1\n        # look at the current tree node and see if there are children or not\n        if 'children' in treenode.keys():\n            #case for a hierarchy node, traverse to all the children\n            for node in treenode['children']:\n                addUniqueIDsToTreeNodes(node)\n        \n\n# assuming we have nodeIDs at each node, traverse the tree down and add a parent\n# node ID to each child. The tree root is a special case, where there is no parent,\n# so it is assumed that a negative value is used for the root.  Otherwise, the routine\n# traverses through the tree and adds 'parentid' to each node.\n\ndef addParentPointerToTreeNodes(treenode,parent):\n    if parent>0:\n        treenode['parent'] = parent\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            addParentPointerToTreeNodes(node,treenode['node_data']['nodeid'])\n        \n        \n#-------------------------------------    \n# here are the top level actions: perform operations and output the tree\n#------------------------------------- \n\naddUniqueIDsToTreeNodes(tree)\naddParentPointerToTreeNodes(tree,-1)\n\ntreeWithParents = tree\n\n\n"}}, "name": "Tree Add Parent Pointers to nodes", "size": 0, "updated": "2018-02-18T23:28:23.690000+00:00"}