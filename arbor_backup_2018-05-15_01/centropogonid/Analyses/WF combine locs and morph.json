{"connections": [{"input": "table", "input_step": "Table name remove postfix", "name": "occurancetable"}, {"input": "table", "input_step": "Table name remove postfix 1", "name": "morphtable"}, {"input": "datatable", "input_step": "Rename Table Column", "output": "tableOut", "output_step": "Table name remove postfix 1"}, {"input": "originalColumnNameList", "input_step": "Rename Table Column", "name": "originalname"}, {"input": "newColumnNameList", "input_step": "Rename Table Column", "name": "newColumnNameList"}, {"input": "inTable1", "input_step": "TableAppendColumns", "output": "tableOut", "output_step": "Table name remove postfix"}, {"input": "inTable2", "input_step": "TableAppendColumns", "output": "newColumnTable", "output_step": "Rename Table Column"}, {"input": "indexColumn", "input_step": "TableAppendColumns", "name": "newColumnNameList"}, {"name": "outTable", "output": "outTable", "output_step": "TableAppendColumns"}], "description": "", "inputs": [{"description": "occurence table with underscores in species names", "format": "rows", "id": "occurancetable", "name": "occurance table", "type": "table", "x": -33, "y": 93}, {"description": "morphology table with underscores in species names", "format": "rows", "id": "morphtable", "name": "morph table", "type": "table", "x": -21, "y": 270}, {"description": "CSV list of columns to rename", "format": "text", "id": "originalname", "name": "original species column name", "type": "string", "x": 27, "y": 402}, {"description": "CSV list of new names for columns to change", "format": "text", "id": "newColumnNameList", "name": "new species name column", "type": "string", "x": 36, "y": 518}], "mode": "workflow", "name": "WF combine locs and morph", "outputs": [{"description": "table containing all input columns of either input table; indexed by columname", "format": "rows", "id": "outTable", "name": "outTable", "type": "table", "x": 1081, "y": 298}], "steps": [{"girderId": "5a8830e354cdbf077f6de42a", "modified": "2018-02-17T13:44:26.217000+00:00", "name": "Table name remove postfix", "task": {"description": "", "inputs": [{"description": "input table with underscores in species names", "format": "rows", "name": "table", "type": "table"}], "mode": "python", "name": "Table name remove postfix", "outputs": [{"description": "same as input table but name and species columns have replaced underscores", "format": "rows", "name": "tableOut", "type": "table"}], "script": "# input: table - table:rows type representing a trait matrix, with \"species\" or \"name\" as the species column header.  \n# output: tableOut - same table with substituted names  \n\n# this routine replaces underscores in species names with spaces.  E.g.  \"heliconia_robusta\" becomes \"heliconia robusta\".\n\ncolumnNames = table['fields']\noutrows = []\n\n# go through the rows and change underscores to spaces for name and species columns.  output is accumulated in outrows\nfor i in range(len(table['rows'])):\n    row = table['rows'][i]\n    if 'name' in row.keys():\n        newname = row['name'].split('_')[0]+'_'+row['name'].split('_')[1]\n        row['name'] = newname\n    elif 'species' in row.keys():\n        newname = row['species'].split('_')[0]+'_'+row['species'].split('_')[1]\n        row['species'] = newname\n    elif 'Species' in row.keys():\n        newname = row['Species'].split('_')[0]+'_'+row['Species'].split('_')[1]\n        row['Species'] = newname\n    outrows.append(row)\n\n# compose output object\ntableOut = {}\ntableOut['fields'] = columnNames\ntableOut['rows'] = outrows\n\n\n    \n        "}, "visualization": false, "x": 226, "y": 84}, {"girderId": "5a8830e354cdbf077f6de42a", "modified": "2018-02-17T13:44:26.217000+00:00", "name": "Table name remove postfix 1", "task": {"description": "", "inputs": [{"description": "input table with underscores in species names", "format": "rows", "name": "table", "type": "table"}], "mode": "python", "name": "Table name remove postfix", "outputs": [{"description": "same as input table but name and species columns have replaced underscores", "format": "rows", "name": "tableOut", "type": "table"}], "script": "# input: table - table:rows type representing a trait matrix, with \"species\" or \"name\" as the species column header.  \n# output: tableOut - same table with substituted names  \n\n# this routine replaces underscores in species names with spaces.  E.g.  \"heliconia_robusta\" becomes \"heliconia robusta\".\n\ncolumnNames = table['fields']\noutrows = []\n\n# go through the rows and change underscores to spaces for name and species columns.  output is accumulated in outrows\nfor i in range(len(table['rows'])):\n    row = table['rows'][i]\n    if 'name' in row.keys():\n        newname = row['name'].split('_')[0]+'_'+row['name'].split('_')[1]\n        row['name'] = newname\n    elif 'species' in row.keys():\n        newname = row['species'].split('_')[0]+'_'+row['species'].split('_')[1]\n        row['species'] = newname\n    elif 'Species' in row.keys():\n        newname = row['Species'].split('_')[0]+'_'+row['Species'].split('_')[1]\n        row['Species'] = newname\n    outrows.append(row)\n\n# compose output object\ntableOut = {}\ntableOut['fields'] = columnNames\ntableOut['rows'] = outrows\n\n\n    \n        "}, "visualization": false, "x": 228, "y": 236}, {"girderId": "577b698a54cdbf3c14cc45f5", "modified": "2016-07-05T08:02:19.435000+00:00", "name": "Rename Table Column", "task": {"inputs": [{"format": "rows", "name": "datatable", "type": "table"}, {"description": "CSV list of columns to rename", "format": "text", "name": "originalColumnNameList", "type": "string"}, {"description": "CSV list of new names for columns to change", "format": "text", "name": "newColumnNameList", "type": "string"}], "mode": "python", "name": "Rename Table Column", "outputs": [{"format": "rows", "name": "newColumnTable", "type": "table"}], "script": "# this analysis expects an input table with a larger number of columns than are desired in the output table.  \n# The analysis also expects a single column input table containing the names of columns to keep in the output table. \n# This is similar to the fieldfile format for mongoDB, with one field per line....\n\n# input: datatable - data table with lots of columns (relatively speaking)\n# input: originalColumnNameList - single string with column names to keep\n# input: newColumnNameList - smaller data table that preserves only the named columns from the input datatable\n# output: newColumnTable\n\n# revision history:\n# 09/16/14 CRL Not working yet\n# 09/17/14 CRL has run on a few datasets using single column replacement, more testing needed\n\n# 03/2015 - uncovered a case where a column name had embedded spaces in it \"Genus _Species\".  Ouch, line 17 deletes the space and then it doesn't match \n# against the original table anymore\n\ninfields = datatable['fields']\nnospaceoriginal = originalColumnNameList.replace(\" \",\"\")\n#nospaceoriginal = originalColumnNameList\nnospacenew = newColumnNameList.replace(\" \",\"\")\noriginallist = nospaceoriginal.split(',')\nnewlist = nospacenew.split(',')\n\n# now loop through the source table and copy records if the column names didn't change.  Assign the value\n# to a new column header if this column name has been changed.  The original and new lists have to be in the same order\n\noutrows = []\nfor row in datatable['rows']:\n    outrow = {}\n    for field in infields:\n        if field in originallist:\n            # assign a new column name to this entry, find it in the same position from the new name list\n            outrow[newlist[originallist.index(field)]] = row[field]\n        else:\n            outrow[field] = row[field]\n    outrows.append(outrow)\n\n# traverse the first row to see what attributes are present in the output table    \noutfields = []    \nfor field in outrows[0]:\n    outfields.append(field)\n      \n# build the output table in table.rows format        \nnewColumnTable = {}\nnewColumnTable['fields'] = outfields\nnewColumnTable['rows'] = outrows\n"}, "visualization": false, "x": 520, "y": 290}, {"girderId": "5a882b1454cdbf077f6de412", "modified": "2018-02-17T13:16:04.378000+00:00", "name": "TableAppendColumns", "task": {"inputs": [{"description": "first input table", "format": "rows", "name": "inTable1", "type": "table"}, {"description": "second input table", "format": "rows", "name": "inTable2", "type": "table"}, {"description": "name of attribute to use to merge table row data together", "domain": {"format": "column.names", "input": "inTable1"}, "format": "text", "name": "indexColumn", "type": "string"}], "mode": "python", "name": "TableAppendColumns", "outputs": [{"description": "table containing all input columns of either input table; indexed by columname", "format": "rows", "name": "outTable", "type": "table"}], "script": "\n# input: inTable1 - a list of rows (2D table)\n# input: inTable2 = a second list of rows\n# input: indexColumn - an attribute name to use as an index to merge data together\n# output: outTable\n\n# merge the columns together.  This analysis assumes that each table has a \n\noutTable = {}\n\n        \n# prepare for the output table format of table:rows        \ncolumnHeaders1 = inTable1['fields']\ncolumnHeaders2 = inTable2['fields']\n\noutRows = []\noutColumns = []\n\n# use the first table as the master.  Iterate through all of its rows and use the value of the index \n# column to select the proper row in the second table, so the additional attributes can be merged into the output\nfor i in range(len(inTable1['rows'])):\n    row = inTable1['rows'][i]\n    for j in range(len(inTable2['rows'])):\n        if inTable2['rows'][j][indexColumn] == row[indexColumn]:\n            # this row from table2 matches, so loop through its entries and add them to the output row\n            for k in inTable2['rows'][j]:\n                row[k] = inTable2['rows'][j][k]\n            break;\n    outRows.append(row)\n\n    \n# now fix the column headers to be the union of both sets of input column headers\n\nfor i in columnHeaders1:\n    if i not in outColumns:\n        outColumns.append(i)\n\nfor i in columnHeaders2:\n    if i not in outColumns:\n        outColumns.append(i)\n        \noutTable = {'fields': outColumns,'rows':outRows}"}, "visualization": false, "x": 817, "y": 301}]}