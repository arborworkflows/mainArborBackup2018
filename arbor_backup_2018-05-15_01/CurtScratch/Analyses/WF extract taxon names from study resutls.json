{"connections": [{"input": "datatable", "input_step": "Extact columns by string", "output": "returnedStudies", "output_step": "Explore Study Trees (Return Tree Info) from Taxon Name"}, {"input": "taxonName", "input_step": "Explore Study Trees (Return Tree Info) from Taxon Name", "name": "taxonName"}, {"input": "outfieldstring", "input_step": "Extact columns by string", "name": "outfieldstring"}, {"name": "outtable", "output": "outtable", "output_step": "Extact columns by string"}], "description": "", "inputs": [{"format": "text", "id": "taxonName", "name": "taxonName", "type": "string", "x": 18, "y": 88}, {"format": "text", "id": "outfieldstring", "name": "outfieldstring", "type": "string", "x": 215, "y": 332}], "mode": "workflow", "name": "WF extract taxon names from study resutls", "outputs": [{"format": "rows", "id": "outtable", "name": "outtable", "type": "table", "x": 889, "y": 201}], "steps": [{"girderId": "58fb9a0554cdbf552d799227", "modified": "2017-05-07T18:50:39.540000+00:00", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "task": {"description": "", "inputs": [{"format": "text", "name": "taxonName", "type": "string"}], "mode": "python", "name": "Explore Study Trees (Return Tree Info) from Taxon Name", "outputs": [{"format": "rows", "name": "returnedStudies", "type": "table"}], "script": "#\n# OpenTreeExploreNamesFromString\n#\n# description: this analysis expects a comma separated list consisting of scientific names.\n# The analysis consults the OpenTree API and extracts canonical names from the OpenTree taxonomy.\n# The output table consists of several columns containint the OpenTree name and taxonomy ID and other relevant information. \n# \n# input: taxonName - single scientific name(s) separated by commas\n# output: outTable -  table with list of studies associated with the taxonname passed as a parameter.\n#\n# maxReturnLength - (could be a parameter, but is defaulted below) max amount of rows of lookups to return\n\nimport requests\nimport unicodedata\n\noutrows = []\nstringdebug = ''\n\nreturncount = 0\n\n\n# ideally, this could be a parameter, but this is an exploratory module, so assume a limit and don't make the \n# user enter it every time\nmaxReturnLength = 100\n\n# build an OTL query to return the matching ottId we want to use to request taxa \npayload = {'property' :'ot:ottTaxonName','value': taxonName,'verbose':'true'}\nresp = requests.post('https://api.opentreeoflife.org/v3/studies/find_trees',data=payload)\n\nreturnedrecs = resp.json()['matched_studies']\n\n# look through all the return records from OpenTree. include them all in the output, but especially\n# traverse the list of trees included in the studies and printout a string that discusses the trees included \n# in the studies\n\nfor index in range(len(returnedrecs)):\n    thisresult = returnedrecs[index]\n    \n    # add a pointer to the opentree curator page for this study\n    thisresult['Study Page URL'] = 'https://tree.opentreeoflife.org/curator/study/view/'+thisresult['ot:studyId']\n    \n    returncount += 1\n    outrows.append(thisresult)\n    # for each returned tree in this study, add some info about it\n    treeinfostring = ''\n    trees = thisresult['matched_trees']\n    for tree in trees:\n        # print out info about the tree, work hard to suppress wierdness from unicode values so the analysis will generally run\n        treeinfostring += \"treeid: \"+unicodedata.normalize('NFKD',tree['oti_tree_id']).encode('ascii','ignore')\n        # only some trees will have branch lengths, so check for existance before printing the info.  \n        if 'ot:branchLengthMode' in tree.keys():\n            # Then some trees have the existance of the field but there is no value entered, so assume these should be filtered out\n            if len(tree['ot:branchLengthMode']) >0:\n                treeinfostring += \" branchlengths: \"+unicodedata.normalize('NFKD',tree['ot:branchLengthMode']).encode('ascii','ignore')\n        treeinfostring += \"; \"\n        #treeinfo.append(treeinfostring)\n    thisresult['tree summary'] = treeinfostring\n        \n\n\n    # if we have already returned the max number of rows, break out of the loop             \n    if returncount>maxReturnLength:\n        break;\n\n\n# build the headers for the output table, the return might be empty, so do crash, just return an empty table\noutColumns = []\nif len(returnedrecs) > 0:\n    for column in returnedrecs[0].keys():\n        outColumns.append(column)\n\n# setup the output in table:rows format with the headers explicitly listed\nreturnedStudies = {'fields': outColumns,\n            'rows':  outrows}\n            \n     "}, "visualization": false, "x": 200, "y": 200}, {"girderId": "577b698a54cdbf3c14cc45f0", "modified": "2016-07-05T08:02:19.316000+00:00", "name": "Extact columns by string", "task": {"inputs": [{"format": "rows", "name": "datatable", "type": "table"}, {"format": "text", "name": "outfieldstring", "type": "string"}], "mode": "python", "name": "Extact columns by string", "outputs": [{"format": "rows", "name": "outtable", "type": "table"}], "script": "# this analysis expects an input table with a larger number of columns than are desired in the output table.  \n# The analysis also expects a single column input table containing the names of columns to keep in the output table. \n# This is similar to the fieldfile format for mongoDB, with one field per line....\n\n# input: datatable - data table with lots of columns (relatively speaking)\n# input: outfieldstring - single string with column names to keep\n# output: outtable - smaller data table that preserves only the named columns from the input datatable\n\n# revision history:\n# 09/02/14 CRL fixed problem with spaces in column selection string\n\ninfields = datatable['fields']\nnospacestring = outfieldstring.replace(\" \",\"\")\noutfields = nospacestring.split(',')\n\n\n# now loop through the source table and append only selected columns to the output data record\n\noutrows = []\nfor row in datatable['rows']:\n    outrow = {}\n    for field in outfields:\n        outrow[field] = row[field]\n    outrows.append(outrow)\n        \nouttable = {}\nouttable['fields'] = outfields\nouttable['rows'] = outrows\n"}, "visualization": false, "x": 589, "y": 201}]}