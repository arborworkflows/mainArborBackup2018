{"_id": "5a09d49854cdbf0a235975b1", "_modelType": "item", "baseParentId": "58a659bc54cdbf04513b9f48", "baseParentType": "collection", "created": "2017-11-13T17:21:28.986000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "58a659bc54cdbf04513b9f49", "meta": {"analysis": {"connections": [{"input": "query", "input_step": "Build Matrix from EOL query", "name": "animal or plant name to look for"}, {"input": "maxImagesPerTaxon", "input_step": "Build Matrix from EOL query", "name": "max number of images to return per taxon"}, {"input": "intable", "input_step": "Build Tree from EOL Matrix", "output": "matrix", "output_step": "Build Matrix from EOL query"}, {"input": "eolTaxonTable", "input_step": "Extract EOL traits from Page Link Table", "output": "matrix", "output_step": "Build Matrix from EOL query"}, {"input": "tree", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "outTree", "output_step": "Build Tree from EOL Matrix"}, {"input": "matrix", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "traitMatrix", "output_step": "Extract EOL traits from Page Link Table"}, {"input": "image_reference_table", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "imageLinks", "output_step": "Build Matrix from EOL query"}, {"name": "tree_with_traits", "output": "tree_with_traits", "output_step": "Create Tree with Image LInks for PhyloPen v2"}, {"name": "console_output", "output": "console_output", "output_step": "Create Tree with Image LInks for PhyloPen v2"}], "description": "", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "animal or plant name to look for", "name": "animal or plant name to look for", "type": "string", "x": 17, "y": 37}, {"default": {"data": "5", "format": "text", "type": "string"}, "description": "limit of how many images will be added to the image table for each taxon", "format": "number", "id": "max number of images to return per taxon", "name": "max number of images to return per taxon", "type": "number", "x": 32, "y": 344}], "mode": "workflow", "name": "WF2 All-EOL build PhyloPen Dataset", "outputs": [{"description": "tree with trait and image reference data in the named nodes", "format": "nested", "id": "tree_with_traits", "name": "tree_with_traits", "type": "tree", "x": 1122, "y": 108}, {"description": "running print statements during execution to understand/debug any problems", "format": "string", "id": "console_output", "name": "console_output", "type": "string", "x": 1090, "y": 380}], "steps": [{"girderId": "58e7e37854cdbf04513b9fc2", "modified": "2018-04-08T20:14:11.101000+00:00", "name": "Build Matrix from EOL query", "task": {"description": "", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "query", "name": "animal or plant name to look for", "type": "string"}, {"default": {"data": "5", "format": "text", "type": "string"}, "description": "limit of how many images will be added to the image table for each taxon", "format": "number", "id": "maxImagesPerTaxon", "name": "max number of images to return per taxon", "type": "number"}], "mode": "python", "name": "Build Matrix from EOL query", "outputs": [{"description": "table of name and EOL pages discovered to match a query", "format": "rows", "id": "matrix", "name": "matrix of taxa discovered on EOL", "type": "table"}, {"description": "a two-column table with species name and extra images, up to the max number of images, each image in a separate row", "format": "rows", "id": "imageLinks", "name": "Image Link table", "type": "table"}], "script": "#\n# access the EOL API to find matching taxa/subtaxa that match a query term\n# input: query (string)\n# outputs: matrix - a single entry for each species, along with its EOL link and an image\n# imageLinks: a two column table, with a row for every image discovered.  The schema is 'name','url'\n# maxImagesPerTaxon: an integer specifying how many images to return for a single species\n\nimport requests\nimport string\n\nfrom lxml import html\neolquery = 'http://eol.org/api/search/1.0.json?q='+query\nresponse = requests.get(eolquery)\njsonReturn = response.json()\n\n# now go through the results returned and pull out the name and EOL page number for each \n# search return (taxon) which matched.\n\n# start with an empty output matrix\nmatrix = {}\nmatrix['fields'] = ['name','pagenumber','page','image']\nmatrix['rows'] = []\n\n# create an empty image url table\nimageLinks = {}\nimageLinks['fields'] = ['name','url']\nimageLinks['rows'] = []\n\n\n# get rid of any words past the first two and suppress following punctuation, so names like 'Carnivora Bowdich, 1821'\n# will be output as 'Carnivora bowdich'.  Capitalization is enforced for first word and lowercase on second word,\n# since this is the Latin name (scientific name) convention\n\n# get rid of any words past the first two and suppress following punctuation\ndef cleanTaxonName(name):\n    spaceSplit = name.split(' ')\n    if len(spaceSplit)>1:\n        clean = spaceSplit[0].capitalize() + ' '+ spaceSplit[1].lower()\n    else:\n        clean = spaceSplit[0].capitalize()\n    return clean.replace(',','')\n\n# some duplicates return from the search, so put the names in a set and check\n# that only unique entries are added to the table\nnameSet = set()\n\nfor res in jsonReturn['results']:\n    name = res['title']\n    link = res['link']\n    print '***Exploring name:',name\n    \n    # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n    cleanedName = cleanTaxonName(name)\n    print 'name cleaned to:',cleanedName\n    \n    # test if we have seen this taxon before\n    if cleanedName not in nameSet:\n        nameSet.add(cleanedName)\n\n      \n        #nameTokens = name.split(' ')\n        #cleanedName = ' '.join(nameTokens[:2])\n        \n        # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n        # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n        # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n        # These mess up opentree TNRS, so truncate the strings. \n        \n        #if '(' in cleanedName:\n        #    cleanedName = name[0:name.find(' (')]\n        #if ',' in cleanedName:\n        #    cleanedName = cleanedName[0:cleanedName.find(',')]\n        #if '1' in cleanedName:\n        #    cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n            \n        # store in output row; the cleaning operation is largely redundant, but this same routine is used in the \n        # \"tree from matrix\" method, so we want to make sure the matrix names and tip names match as much as practical\n        taxaRow = {}\n        taxaRow['name'] =  cleanedName\n    \n        #find the page number and images for this taxon.  We extract the page number from the page link\n        questionMarkPosition = link.find('?')\n        eolPageNumber = link[15:questionMarkPosition]\n        #print 'page number:',eolPageNumber\n        taxaRow['pagenumber'] = eolPageNumber\n        taxaRow['page'] = link\n    \n        # now find the images on the corresponding taxon media page\n        mediaQuery = 'http://eol.org/pages/'+eolPageNumber+'/media'\n        response = requests.get(mediaQuery)\n        jsonReturn = response.content\n        tree = html.fromstring(response.content)\n        #print jsonReturn\n        images = tree.xpath('//img/@src')\n        names = tree.xpath('//img/@alt')\n            \n        # use sets to remove duplicates.  This assumes the names and images duplicate at the same time. This could\n        # be a risky assumption. \n        uniqueImages = set(images)\n        uniqueNames = set(names)\n        \n        # return only the first five in the list. Use Max function to \n        # Return fewer images if there were less than the specified max available\n        for index in range(min(len(uniqueImages),maxImagesPerTaxon)):\n            imageRow = {}\n            #url = uniqueImages[index]\n            # have to extract from sets, not use an index\n            url = uniqueImages.pop()\n            imageRow['name'] = taxaRow['name']\n            imageRow['url'] = url\n            imageLinks['rows'].append(imageRow)\n            if index == 0:\n                taxaRow['image'] = url\n    \n        # add this taxa to the output table        \n        matrix['rows'].append(taxaRow)\n    \n        \n        \n        \n        \n        \n        \n    "}, "visualization": false, "x": 234, "y": 231}, {"girderId": "5a32dd9254cdbf077f6de257", "modified": "2018-03-04T00:08:35.105000+00:00", "name": "Build Tree from EOL Matrix", "task": {"description": "Take a string query from a user for a clade or organism, such as \"bears\", \"ursidae\", \"oysters\", etc.  and return a tree containing all the returns, according to the Encylopedia of Life search interface.  The trees returned are likely to contain the desired organisms as well as \"false positives\", such as returning a \"catfish\" when \"cat\" was the search term. This could, itself, be a helpful educational side-effect. ", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "rows", "id": "intable", "name": "EOL taxon name and pagenumber matrix", "type": "table"}], "mode": "python", "name": "Build Tree from EOL Matrix", "outputs": [{"description": "a printable string which is a depth-first traversal of the tree node names", "format": "text", "id": "outstring", "name": "String output of tree traversal", "type": "string"}, {"description": "tree in nested format, created through EOL hierarchy API calls", "format": "nested", "id": "outTree", "name": "Tree Extracted from EOL hierarchy", "type": "tree"}, {"description": "A count of the number of nodes in the returned tree.  Output as a string", "format": "text", "id": "treeNodeCount", "name": "Number of nodes in the tree", "type": "string"}], "script": "#\n# access the EOL API to find matching taxa/subtaxa that match a query term\n# input: EOL matrix generated from previou method (table:rows)\n# outputs: tree - output a tree created from accessing the EOL pages and hierarchies API\n#\n# assumptions:  the input table is assumed to have a pagenumber column, that corresponds to the\n# EOL taxon concept we will look up\n\nimport requests\nfrom lxml import html\nimport json\n\n\n# global variables shared and updated by multiple routines during this method\n\nnodes = {}\nwasInTreeCount = 0\noutstring = ''\noutTree = {}\nfirstTime = True\n\n# update the 'children' reference to include a new child.  This routine returns the \n# modified parent node\n\ndef addChildNodeToParent(node,parent):\n    # if this node is not already a child, then add it in the children dictionary\n    if node['taxonID'] not in parent['children'].keys():\n        parent['children'][node['taxonID']] = node['taxonID']\n    else:\n        #if this node has already been added, then do nothing\n        pass\n    return parent\n\n\n# add a single node to the tree.  This checks to see if the parent is already in the tree\n# and updates the children links.  This is designed to be callable repeately with the same node\n# but the node will only be entered in the tree once.  The EOL APIs return a list from a node ID\n# all the way back to the root of the TOL, so higher taxon will be encountered multiple times during\n# the construction of a tree. \n\ndef addNodeToTree(thisNode):\n    global nodes\n    global wasInTreeCount\n    global outstring\n    #print 'attempting to add',thisNode['taxonID']\n    if thisNode['taxonID'] not in nodes.keys():\n        #print 'not in tree'\n        # first time we've seen this node, so add it without children\n        thisNode['children'] = {}\n        nodes[thisNode['taxonID']] = thisNode\n    else: \n        #print 'was in tree'\n        wasInTreeCount += 1\n        # we have seen this node before because each node is entered only once\n        pass\n    # add a child link to our parent node by update the parent node.  This will fail on the first\n    # node added, so test that the parent is in the accumulator already\n\n    if thisNode['parentNameUsageID'] in nodes.keys():\n        nodes[thisNode['parentNameUsageID']] =   addChildNodeToParent(thisNode,nodes[thisNode['parentNameUsageID']])\n        #outstring += 'attaching '+ str(thisNode['taxonID']) + ' to '+ str(thisNode['parentNameUsageID'])\n        #outstring += '\\n'\n    else:\n        pass\n        #outstring += 'parent of ' + str(thisNode['scientificName']) + ' was not found in the tree'+'\\n'\n\n\n# add a leaf node and all its ancestors to the tree.  This is called each time the EOL hierarchy returns a path from the \n# TOL root to a specific OTU.  All the nodes along the path are added to the tree in order from higher taxon to lower tacon\n\ndef addNodeAndAncestorsToTree(node, ancestors):\n    global nodes\n    global outstring\n    lastAncestor = ''\n    #loop through the ancestors and add them to the accumulator\n    for thisNode in ancestors:\n        addNodeToTree(thisNode)\n        lastAncestor = thisNode\n    #  set the parent to the taxonID of the last (most recent) ancestor\n    # if there were no ancestors in the list, then don't add this node\n    if lastAncestor != '':\n        # fix since the leaves have their taxonID listed in a different place, so copy over \n        node['taxonID'] = node['identifier']\n        # link this leaf to the last ancestor returned in the list\n        node['parentNameUsageID'] = lastAncestor['taxonID']\n        addNodeToTree(node)\n    else:\n        print 'add node called with null node. ignoring'\n        outstring += 'add node called with null node\\n'\n  \n# once the nodes have all been loaded in the tree, one of them should have a parent which has taxonID=0 (since it \n# has no parent.  This will be the root, so scan throgh the nodes and return the index \n \ndef findRootTaxonID():\n    global nodes\n    # find root\n    root = -1\n    for key in nodes.keys():\n        if nodes[key]['parentNameUsageID'] == 0:\n            root = key\n            break\n    return root\n    \n# this routine prints out a single node in the tree with an indent according to the tree level. It is designed\n# to be called during a depth-first traversal of the tree.  Output goes to standard out via python's print statement\n# and/or is concatenated to an outputstring for output to other workflow steps or review. \n\ndef outputNode(node,level):\n    global outstring\n    indentString=''\n    for i in range(0,level):\n        indentString += ' '\n    #print indentString,node['scientificName']\n    outstring += indentString\n    outstring += str(cleanTaxonName(node['scientificName']))\n    outstring += '\\n'\n    \n    \n# this prints out the tree by looking for the root (with parentID=0) and then conducts a depth-first traversal\n# of the tree, outputting nodes as they are encountered.  \n\ndef printTree():\n    global nodes\n    # find root\n    root = findRootTaxonID()\n    #print '----------- tree -------'\n    traverseNode(nodes[root],0)\n \n\n# get rid of any words past the first two and suppress following punctuation, so names like 'Carnivora Bowdich, 1821'\n# will be output as 'Carnivora Bowdich'.  Capitalization is enforced for first word and lowercase on second word,\n# since this is the Latin name (scientific name) convention\n\ndef cleanTaxonName(name):\n    spaceSplit = name.split(' ')\n    if len(spaceSplit)>1:\n        clean = spaceSplit[0].capitalize() + ' '+ spaceSplit[1].lower()\n    else:\n        clean = spaceSplit[0].capitalize()\n    return clean.translate(None, string.punctuation)\n    \n# This method is called repeatedly for each node in the tree during a tree traversal.  The node information is \n# output and the traversal continues with any children nodes below the current node. \n    \ndef traverseNode(node,level):\n    global nodes\n    # start at the root\n    outputNode(node,level)\n    for child in node['children']:\n        traverseNode(nodes[child],level+1)\n        \n# -- create tree:nested output is based on the three string output routines above with only tiny modifications to handle \n# -- changes to the global outTree data structure\n        \ndef outputNodeNested(parent,node,level):\n    global firstTime\n    parent = {}\n    parent['node_data'] = {}\n    parent['node_data']['node name'] = cleanTaxonName(node['scientificName'])\n    parent['node_data']['nodeid'] = node['taxonID']\n    parent[\"edge_fields\"] = [\"weight\"]\n    parent[\"node_fields\"] = [\"node name\", \"nodeid\"]\n    parent['children'] = []\n    # if this is not the root, then include a weight one edge\n    if firstTime:\n        firstTime = False\n        parent[\"edge_fields\"] = [\"weight\"]\n        parent[\"node_fields\"] = [\"node name\", \"nodeid\"]\n    else:\n        parent['edge_data'] = {'weight':1.0}\n    return parent\n\n    \n    \n# this prints out the tree by looking for the root (with parentID=0) and then conducts a depth-first traversal\n# of the tree, outputting nodes as they are encountered.  \n\ndef printTreeNested():\n    global nodes\n    global outTree\n    # find root\n    root = findRootTaxonID()\n    #print '----------- tree -------'\n    outTree = outputNodeNested(outTree,nodes[root],0)\n    for child in nodes[root]['children']:\n        outTree = traverseNodeNested(outTree,nodes[root],0)\n    \n       \n# This method is called repeatedly for each node in the tree during a tree traversal.  The node information is \n# output and the traversal continues with any children nodes below the current node. \n    \ndef traverseNodeNested(parent,node,level):\n    global nodes\n    # start at the root\n    parent = outputNodeNested(parent,node,level)\n    for child in node['children']:\n        parent['children'].append(traverseNodeNested(parent,nodes[child],level+1))\n    return parent\n\ndef cleanTaxonName(name):\n    spaceSplit = name.split(' ')\n    if len(spaceSplit)>1:\n        clean = spaceSplit[0].capitalize() + ' '+ spaceSplit[1].lower()\n    else:\n        clean = spaceSplit[0].capitalize()\n    return clean.replace(',','')        \n        \n#----------------------------------------------------\n# Beginning of the main loop of the method\n#----------------------------------------------------\n\n\n# go through each entry and find the corresponding EOL page for this search return.  The \n# search returns are the leaves of the tree, so find the EOL pages. Then lookup the taxonID\n# and make a hierarchy call to get the path from the root of the TOL to this leaf.  Add these\n# paths one at a time to build a tree that contains all the search returns.\n\nfor row in intable['rows']:\n\n    query = row['pagenumber']\n    pagequery = 'http://eol.org/api/pages/1.0.json?id='+query\n    response = requests.get(pagequery)\n    # ignore empty returns without crashing\n    try:\n        jsonResponse = response.json()\n        print 'return:',jsonResponse\n \n        # now loop through the taxonConcepts (tc) returned as pages and retrieve their paths from the root of the TOL\n        for tc in jsonResponse['taxonConcepts']:\n        \n            # EOL uses multiple taxonomies instead of creating a single one, such as what the OpenTree is doing.  \n            # for this analysis, we pick one and deal with the strenghts and weaknesses of that particular hierarchy.\n            # It was observed that NCBI had more levels of depth, but seemed more taxonomic, with less readable content.\n            # Since one of the main applications for this is education, ITIS seems to offer a simpler, denser hierarchy.\n            # We select only the entries corresponding to the hierarchy of choice and look them up to add the paths\n            # to the output tree. Sometimes variation of this string exists, so checking for ITIS inside\n\n            #if tc[\"nameAccordingTo\"] == 'Integrated Taxonomic Information System (ITIS)'\n            #if tc[\"nameAccordingTo\"] == 'NCBI Taxonomy':\n        \n            if 'ITIS' in tc[\"nameAccordingTo\"]:\n                #print tc['taxonRank'],tc['identifier']\n                id = str(tc['identifier']) \n                eolquery = 'http://eol.org/api/hierarchy_entries/1.0.json/?id='+id\n                hierarchy = requests.get(eolquery)\n                # sometimes EOL returns empty, so just ignore this taxon\n                try:\n                    hierJson = hierarchy.json()\n                    addNodeAndAncestorsToTree(tc,hierJson['ancestors'])\n                except:\n                    outstring += 'ignoring ' + str(tc['scientificName']) + ' because EOL hierarchy returned empty\\n'\n                    pass\n                break\n    except:\n        outstring += 'no page found for '+ str(tc['scientificName']) + '\\n'\n        pass\n#print 'times a node was revisited:',wasInTreeCount\n\n# prepare the output\ntreeNodeCount = str(len(nodes.keys()))\nprint 'number of nodes in the tree:',treeNodeCount\n\nprintTree() \nprintTreeNested()\n        \n        \n        \n        \n        \n    "}, "visualization": false, "x": 443, "y": 47}, {"girderId": "59c92e0c54cdbf0a2359755b", "modified": "2018-01-14T01:04:54.965266+00:00", "name": "Extract EOL traits from Page Link Table", "task": {"description": "Input a table containing taxon names (column header \"name\") and EOL page numbers (column header 'pagenumber') corresponding to EOL pages.  Perform a query for each taxon in the input table and compile a trait matrix for whatever traits are available on the EOL pages.  Missing traits are filled in with empty strings. ", "inputs": [{"format": "rows", "id": "eolTaxonTable", "name": "Table of EOL taxon names and pagenumbers", "type": "table"}], "mode": "python", "name": "Extract EOL traits from Page Link Table", "outputs": [{"description": "A trait matrix compiled from traits on EOL pages", "format": "rows", "id": "traitMatrix", "name": "Trait Matrix from EOL Pages", "type": "table"}, {"format": "text", "id": "debugString", "name": "debugString", "type": "string"}], "script": "\n# parse the incoming matrix, which is assumed to have at least two columns ('name' and 'pagenumber') for the EOL\n# pages we want to use to build a trait list. \n\n# Each taxon has different traits, so we will extract the traits into separate dictionaries for each taxon (each row of matrix). Then we traverse\n# this dictionary of dictionaries afterwards to pull together the final matrix. Also creata a global list of discovered traits\n# across all taxa in the matrix to be the column headers of the final matrix\n\nimport requests\n\ntraitsDictsByNameDictionary = {}\ntraitMatrixUniqueFields = set()\ndebugString = ''\n\n# EOl Taxonomy returns complex names that confuse OpenTree because the taxonomy identifiers are \"informal\". We want to output a cleaned\n# name that will match the cleaned name output from the taxon tables so names can be used to join up traits and tree tips later.  \ndef cleanupEolName(name):\n    # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n    nameTokens = name.split(' ')\n    cleanedName = ' '.join(nameTokens[:2])\n        \n    # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n    # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n    # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n    # These mess up opentree TNRS, so truncate the strings.       \n    if '(' in cleanedName:\n        cleanedName = name[0:name.find(' (')]\n    if ',' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(',')]\n    if '1' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n    return cleanedName\n    \n    \nfor inrow in eolTaxonTable['rows']:\n    # find the page number from the table\n    eolPageNumber = inrow['pagenumber']\n    # now find the traits of the taxon on this page\n    query = 'http://eol.org/api/traits/'+eolPageNumber\n    response = requests.get(query)\n    #debugString += 'trait return:\\n'+response.text\n    try:\n        jsonReturn = response.json()\n        traitDict = {}\n        for attr in jsonReturn['item']['traits']:\n            # discover each trait name for this taxon and add it to a set (to keep each name only once)\n            traitMatrixUniqueFields.add(attr['predicate'])\n            # store this trait in a dictionary that contains entries for only this taxon\n            traitDict[attr['predicate']] = attr['value'] \n\n        # store the traits discovered for this taxon in the whole matrix dictionary, indexed by name.  This has\n        # a compression affect if a taxon is listed multiple times, it will only appear once in the output matrix. We will lose\n        # information by over-writing, but the matrix will be in traditional form, matching a tree with only one tip per taxon name\n        traitsDictsByNameDictionary[inrow['name']] = traitDict\n    except:\n        # ignore empty responses or error responses from EOL.  Recently, we have been receiving code 429 (too many requests)\n        pass\n\n#print 'columns in matrix:',traitMatrixUniqueFields\n#print 'whole dictionary:',traitsDictsByNameDictionary\n\n# create the output table:rows datatype for the matrix. Put the taxon name first, then the discovered traits\ntraitMatrix = {}\ntraitMatrix['fields'] = list(traitMatrixUniqueFields)\ntraitMatrix['fields'].insert(0,'name')\ntraitMatrix['fields'].insert(1,'eolName')\ntraitMatrix['rows'] = []\n\n\nfor taxon in traitsDictsByNameDictionary.keys():\n    #print 'compiling records for:',taxon\n    row = {}\n    for trait in traitMatrix['fields']:\n        # if this taxon had the trait, copy it, if not, create an empty cell so the matrix is not sparse\n        row[trait] = traitsDictsByNameDictionary[taxon][trait] if trait in traitsDictsByNameDictionary[taxon] else ''\n    # add the taxon name and this taxon's row to the matrix\n    row['name'] = cleanupEolName(taxon)\n    row['eolName'] = taxon\n    traitMatrix['rows'].append(row)\n\n#print 'final matrix:'\n#print traitMatrix\n"}, "visualization": false, "x": 524, "y": 192}, {"girderId": "58a659fb54cdbf04513b9f4c", "modified": "2018-04-14T17:39:54.298000+00:00", "name": "Create Tree with Image LInks for PhyloPen v2", "task": {"description": "", "inputs": [{"description": "tree to add characters and images to", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}, {"description": "character matrix to add to tree tips", "format": "rows", "id": "matrix", "name": "matrix", "type": "table"}, {"description": "2 column table (taxon, imageURL) for adding image references to taxa", "format": "rows", "id": "image_reference_table", "name": "image_reference_table", "type": "table"}], "mode": "python", "name": "Create Tree with Image LInks for PhyloPen v2", "outputs": [{"description": "tree with trait and image reference data in the named nodes", "format": "nested", "id": "tree_with_traits", "name": "tree_with_traits", "type": "tree"}, {"description": "running print statements during execution to understand/debug any problems", "format": "string", "id": "console_output", "name": "console_output", "type": "string"}], "script": "#\n# Take a tree, matrix, and an image reference table as input. Create a nested format\n# tree with image references and attributes attached to the leaves of the tree for display\n# \n# KnowledgeVis, LLC\n# C Lisle\n#\n# update history\n# 2/22/16 - modified for multiple images option per taxon, with text\n\n# inputs:\n# tree - nested format tree with tipnames that match the matrix names\n# matrix - character matrix with names that match the tree tips\n# image_reference_table - 2 column table with tipname and image URL to load the image from\n\n# look through the rows of the image cross reference table.  This format comes from the phenoscape team\n# and has been processed by a previous method to look up the girder item numbers\ndef returnMatchingImageRecord(name):\n    global image_reference_table\n    record = {}\n    for row in image_reference_table['rows']:\n        #print 'looking for ',name,' in ',row\n        if (('taxon' in row) and (name == row['taxon'])):\n            return row['url']\n        if (('species' in row) and (name == row['species'])):\n            return row['url']\n        if (('name' in row) and (name == row['name'])):\n            return row['url']\n    return record\n          \ndef forceHTTPS(string):\n    return string.replace('http','https')\n    \n# look through the image matching table.  Three options for taxon name are supported because\n# matrices may not always be indexed the same.  We allow name,species, or taxon:\ndef returnMatchingImageRecordList(name):\n    global image_reference_table\n    records = []\n    for row in image_reference_table['rows']:\n        if 'content' in row['url']:\n            #print 'looking for ',name,' in ',row\n            if (('taxon' in row) and (name == row['taxon'])):\n                # if we found a name match, but no image was resolved, don't add this option\n                if len(row['url'])>0:\n                    newrecord = {'image': forceHTTPS(row['url']), 'text': row['taxon']}\n                    if 'character' in row:\n                        newrecord['text'] += '/character='+ str(row['character'])\n                    if 'state' in row:\n                        newrecord['text'] += '/state='+ str(row['state'])\n                    records.append(newrecord)\n            if (('species' in row) and (name == row['species'])):\n                # if we found a name match, but no image was resolved, don't add this option\n                if len(row['url'])>0:\n                    newrecord = {'image': forceHTTPS(row['url']), 'text': row['species']}\n                    if 'character' in row:\n                        newrecord['text'] += '/character='+ str(row['character'])\n                    if 'state' in row:\n                        newrecord['text'] += '/state='+ str(row['state'])\n                    records.append(newrecord)\n            if (('name' in row) and (name == row['name'])):\n                # if we found a name match, but no image was resolved, don't add this option\n                if len(row['url'])>0:\n                    newrecord = {'image': forceHTTPS(row['url']), 'text': row['name']}\n                    if 'character' in row:\n                        newrecord['text'] += '/character='+ str(row['character'])\n                    if 'state' in row:\n                        newrecord['text'] += '/state='+ str(row['state'])\n                    records.append(newrecord)\n    return records\n                        \n# look through the rows of the matrix and return a matching entry.  Return the \n# URL record or an empty set (to avoid run-time errors if data doesn't match\n\ndef returnMatchingMatrixRecord(name):\n    global console_output\n    global matrix\n    record = {}\n    for row in matrix['rows']:\n        print 'looking for ',name,' in matrix ',row\n        console_output += 'looking for name match for: '+name+' in row: '+row['name']\n        if (('name' in row) and (name == row['name'])):\n            return row\n        if (('species' in row) and (name == row['species'])):\n            return row\n        if (('taxa' in row) and (name == row['taxa'])):\n            print 'found taxon match'\n            return row\n    return record\n\n            \ndef convertToNumbers(s):\n    try:\n        return float(s)\n    except:\n        return s\n        \n# traverse through the tree and add records to the tips from the matrix and the image table\ndef addRecordsToTreeTips(treenode,level):\n    global console_output\n    console_output+='ar('+str(level)+') '\n    \n    #if no node weight, add a placeholder value because PhyloPen is looking for node weight \n    if 'node weight' not in treenode['node_data']:\n        treenode['node_data']['node weight'] = 1\n            \n    if len(treenode['children']) > 0:\n        for node in treenode['children']:\n            level = level +1\n            addRecordsToTreeTips(node,level)\n    else:\n        console_output += 'tip: '\n        # this is a tip, add matrix and image information\n        nodename = treenode['node_data']['node name']\n        #console_output += 'searching for matrix entry for'+nodename\n        console_output += nodename+'\\n'\n        traits = returnMatchingMatrixRecord(nodename)\n        #console_output += ' matching trait record is: '+traits['name']+'\\n'\n\n        treenode['node_data']['attributes'] = []\n        # add all columns in the character matrix, unless they are the taxa name, since this is already handled in the 'node name' \n        # Try to convert attribute values to numbers so that we don't return \"235\" when we could return the number 235\n        for trait in traits.keys():\n            if trait not in ['species','name','taxa','image']:\n                traitvalue = convertToNumbers(traits[trait])\n                treenode['node_data']['attributes'].append({trait: traitvalue})\n        \n        # add the image attribute to point to the image binary.  There might be more than one image, so \n        # make the entry always be a list. Later we might change these records to have a key tied to a character\n        # to select which image, but just a list initially\n        nodename = treenode['node_data']['node name']\n        # only add an image record if we found an image to match this taxon\n        imageURLs = returnMatchingImageRecordList(treenode['node_data']['node name'])\n        #print 'matching image record:',imageURL\n        for imageRecord in imageURLs:\n            if 'images' in treenode['node_data']:\n                treenode['node_data']['images'].append(imageRecord)\n            else:\n                treenode['node_data']['images'] = []\n                treenode['node_data']['images'].append(imageRecord)\n\n# this routine adds any matrix categories to the record on the root of the tree that specifies\n# what fields are on the nodes.  PhyloPen uses this to parse for attributes to display in the attribute list UI\n\ndef addTraitsToNodeFieldsRecord(treeroot):\n    global matrix\n    #for field in matrix['fields']:\n    #    if field not in ['species','name','taxa']:\n    #        treeroot['node_fields'].append(field)\n    # indicate an attributes record\n    treeroot['node_fields'].append('attributes')\n    # indicate there could be an images record as well\n    treeroot['node_fields'].append('images')\n\n# ---- top level -----\n\nconsole_output = 'start\\n'\ntree_with_traits = tree\naddRecordsToTreeTips(tree_with_traits,0)\n#addTraitsToNodeFieldsRecord(tree_with_traits)\n\n\n"}, "visualization": false, "x": 886, "y": 227}]}}, "name": "WF2 All-EOL build PhyloPen Dataset", "size": 0, "updated": "2018-04-14T17:40:12.460000+00:00"}