{"description": "", "inputs": [{"default": {"data": "Tree that has tip names of the form genus_species_ottID", "format": "text", "type": "string"}, "description": "tree with open tree names", "format": "nested", "id": "tree", "name": "tree with Open Tree format names", "type": "tree"}], "mode": "python", "name": "Convert OpenTree Tip Names to Scientific Names", "outputs": [{"format": "nested", "id": "tree_scientific_names", "name": "tree with scientific tip names", "type": "tree"}], "script": "# Convert OpenTree Tip Names to Scientific Names\n#\n# C. Lisle\n# KnowledgeVis, LLC\n# \n# released under Apache 2.0 open-source license\n#\n# This analysis is an algorithm to traverse a tree and rename tips from openTree format (genus_species_ottID) to \"genus species\"\n\n# inputs:\n# tree - a tree (nested format) with shortened names on the tips.  Names are the prefix (up to 9 chars) of the genus name\n\n# output:\n# tree_scientific_names - tree (in nested format) with modified names that match the matrix\n\n# setup global values\ndebugOutput = ''\nnodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \n\n\n\n# convert names from genus_species_ottid to \"genus species\"\ndef fixOpenTreeName(tipname):\n    nameTokens = tipname.split('_')\n    if len(nameTokens)>2:\n        newName = ' '.join(nameTokens[0:2])\n    else:\n        # handle special case where there was no species name, don't splice in an ottID\n        newName = nameTokens[0]\n    return newName\n\n# this is an operation to perform on a taxon node to replace its name.  It is called for each taxon of the tree\ndef taxonOperation(node):\n    # only replace names if they exist.  test first so routine doesn't cause a runtime exception if a name is missing\n    if ('node name' in node['node_data'].keys()):\n        originalName = node['node_data']['node name']\n        newName = fixOpenTreeName(originalName)\n        node['node_data']['node name'] = newName\n\n    \n\n# utility routine to recursively traverse through a phylo tree in nested format.  This traversal starts at the top and recursively traverses the tree.\n# once it finds a taxon, then the routine 'taxonOperation' is called with the taxon node as an argument.  \n\ndef treeTraversal(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            treeTraversal(node)\n    else:\n        #case for a taxa. Run a previously-defined operation on the taxon node\n        taxonOperation(treenode)    \n\n# Top Level Operations \n\n#  setup the structures and go through the tree nodes and replace any names with full names from the reference name list.  The traversal replaces names\n# in place, so when the traversal is done the tree has new node names\n\n\ntreeTraversal(tree)\nassignEdgeWeightsIfMissing(tree)\ntree_scientific_names = tree"}