{"_id": "58eb8e1854cdbf552d7990ff", "_modelType": "item", "baseParentId": "58a659bc54cdbf04513b9f48", "baseParentType": "collection", "created": "2017-04-10T13:52:24.624000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "58a659bc54cdbf04513b9f49", "meta": {"analysis": {"connections": [{"input": "nameTable", "input_step": "Lookup names using OpenTree Taxonomy", "output": "matrix", "output_step": "Build Matrix from EOL query"}, {"input": "table", "input_step": "Return the OpenTree subtree from a node list", "output": "outTable", "output_step": "Lookup names using OpenTree Taxonomy"}, {"input": "eolTaxonTable", "input_step": "Extract EOL traits from Page Link Table", "output": "matrix", "output_step": "Build Matrix from EOL query"}, {"input": "tree", "input_step": "Tree Assign Uniform Edge Weights If Missing", "output": "tree", "output_step": "Return the OpenTree subtree from a node list"}, {"input": "tree", "input_step": "Convert OpenTree Tip Names to Scientific Names", "output": "outtree", "output_step": "Tree Assign Uniform Edge Weights If Missing"}, {"input": "tree", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "tree_scientific_names", "output_step": "Convert OpenTree Tip Names to Scientific Names"}, {"input": "matrix", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "traitMatrix", "output_step": "Extract EOL traits from Page Link Table"}, {"input": "image_reference_table", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "imageLinks", "output_step": "Build Matrix from EOL query"}, {"name": "tree_with_traits", "output": "tree_with_traits", "output_step": "Create Tree with Image LInks for PhyloPen v2"}, {"name": "matrix of taxa discovered on EOL", "output": "matrix", "output_step": "Build Matrix from EOL query"}, {"input": "query", "input_step": "Build Matrix from EOL query", "name": "animal or plant name to look for"}, {"input": "maxImagesPerTaxon", "input_step": "Build Matrix from EOL query", "name": "max number of images to return per taxon"}, {"name": "debug output string", "output": "outstring", "output_step": "Return the OpenTree subtree from a node list"}, {"name": "outstring", "output": "outstring", "output_step": "Lookup names using OpenTree Taxonomy"}, {"name": "Trait Matrix from EOL Pages", "output": "traitMatrix", "output_step": "Extract EOL traits from Page Link Table"}], "description": "", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "animal or plant name to look for", "name": "animal or plant name to look for", "type": "string", "x": 17, "y": 37}, {"default": {"data": "5", "format": "text", "type": "string"}, "description": "limit of how many images will be added to the image table for each taxon", "format": "number", "id": "max number of images to return per taxon", "name": "max number of images to return per taxon", "type": "number", "x": 32, "y": 344}], "mode": "workflow", "name": "WF build PhyloPen Dataset from EOL", "outputs": [{"description": "tree with trait and image reference data in the named nodes", "format": "nested", "id": "tree_with_traits", "name": "tree_with_traits", "type": "tree", "x": 1450, "y": 173}, {"description": "table of name and EOL pages discovered to match a query", "format": "rows", "id": "matrix of taxa discovered on EOL", "name": "matrix of taxa discovered on EOL", "type": "table", "x": 629, "y": 371}, {"format": "text", "id": "debug output string", "name": "opentree debug output string", "type": "string", "x": 1173, "y": 11}, {"description": "debug output showing returned data from OpenTree, even if the method fails", "format": "text", "id": "outstring", "name": "OpenTree taxonomy lookup debug string", "type": "string", "x": 981, "y": 584}, {"description": "A trait matrix compiled from traits on EOL pages", "format": "rows", "id": "Trait Matrix from EOL Pages", "name": "Trait Matrix from EOL Pages", "type": "table", "x": 1029, "y": 451}], "steps": [{"girderId": "58e7e37854cdbf04513b9fc2", "modified": "2017-04-10T12:12:24.579000+00:00", "name": "Build Matrix from EOL query", "task": {"description": "", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "query", "name": "animal or plant name to look for", "type": "string"}, {"default": {"data": "5", "format": "text", "type": "string"}, "description": "limit of how many images will be added to the image table for each taxon", "format": "number", "id": "maxImagesPerTaxon", "name": "max number of images to return per taxon", "type": "number"}], "mode": "python", "name": "Build Matrix from EOL query", "outputs": [{"description": "table of name and EOL pages discovered to match a query", "format": "rows", "id": "matrix", "name": "matrix of taxa discovered on EOL", "type": "table"}, {"description": "a two-column table with species name and extra images, up to the max number of images, each image in a separate row", "format": "rows", "id": "imageLinks", "name": "Image Link table", "type": "table"}], "script": "#\n# access the EOL API to find matching taxa/subtaxa that match a query term\n# input: query (string)\n# outputs: matrix - a single entry for each species, along with its EOL link and an image\n# imageLinks: a two column table, with a row for every image discovered.  The schema is 'name','url'\n# maxImagesPerTaxon: an integer specifying how many images to return for a single species\n\nimport requests\nfrom lxml import html\neolquery = 'http://eol.org/api/search/1.0.json?q='+query\nresponse = requests.get(eolquery)\njsonReturn = response.json()\n\n# now go through the results returned and pull out the name and EOL page number for each \n# search return (taxon) which matched.\n\n# start with an empty output matrix\nmatrix = {}\nmatrix['fields'] = ['name','pagenumber','page','image']\nmatrix['rows'] = []\n\n# create an empty image url table\nimageLinks = {}\nimageLinks['fields'] = ['name','url']\nimageLinks['rows'] = []\n\n# some duplicates return from the search, so put the names in a set and check\n# that only unique entries are added to the table\nnameSet = set()\n\nfor res in jsonReturn['results']:\n    name = res['title']\n    link = res['link']\n    print '***Exploring name:',name\n    \n    #test if we have seen this taxon before\n    if name not in nameSet:\n        nameSet.add(name)\n\n        # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n        nameTokens = name.split(' ')\n        cleanedName = ' '.join(nameTokens[:2])\n        \n        # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n        # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n        # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n        # These mess up opentree TNRS, so truncate the strings.       \n        if '(' in cleanedName:\n            cleanedName = name[0:name.find(' (')]\n        if ',' in cleanedName:\n            cleanedName = cleanedName[0:cleanedName.find(',')]\n        if '1' in cleanedName:\n            cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n        \n        # store in output row\n        taxaRow = {}\n        taxaRow['name'] =  cleanedName\n    \n        #find the page number and images for this taxon.  We extract the page number from the page link\n        questionMarkPosition = link.find('?')\n        eolPageNumber = link[15:questionMarkPosition]\n        #print 'page number:',eolPageNumber\n        taxaRow['pagenumber'] = eolPageNumber\n        taxaRow['page'] = link\n    \n        # now find the images on the corresponding taxon media page\n        mediaQuery = 'http://eol.org/pages/'+eolPageNumber+'/media'\n        response = requests.get(mediaQuery)\n        jsonReturn = response.content\n        tree = html.fromstring(response.content)\n        #print jsonReturn\n        images = tree.xpath('//img/@src')\n        names = tree.xpath('//img/@alt')\n            \n        # use sets to remove duplicates.  This assumes the names and images duplicate at the same time. This could\n        # be a risky assumption. \n        uniqueImages = set(images)\n        uniqueNames = set(names)\n        \n        # return only the first five in the list. Use Max function to \n        # Return fewer images if there were less than the specified max available\n        for index in range(min(len(uniqueImages),maxImagesPerTaxon)):\n            imageRow = {}\n            #url = uniqueImages[index]\n            # have to extract from sets, not use an index\n            url = uniqueImages.pop()\n            imageRow['name'] = taxaRow['name']\n            imageRow['url'] = url\n            imageLinks['rows'].append(imageRow)\n            if index == 0:\n                taxaRow['image'] = url\n    \n        # add this taxa to the output table        \n        matrix['rows'].append(taxaRow)\n    \n        \n        \n        \n        \n        \n        \n    "}, "visualization": false, "x": 200, "y": 200}, {"girderId": "58e804e254cdbf7bfe6be9d4", "modified": "2017-04-08T15:14:25.265000+00:00", "name": "Lookup names using OpenTree Taxonomy", "task": {"description": "", "inputs": [{"default": {"data": "'True'", "format": "text", "type": "string"}, "description": "Should OpenTree use fuzzy matching (noticably slower, but better matching). Use 'True' or 'False' strings", "format": "text", "id": "doApproximateMatching", "name": "Allow Approximate Matching", "type": "string"}, {"description": "single column table of scientific names", "format": "rows", "name": "nameTable", "type": "table"}], "mode": "python", "name": "Lookup names using OpenTree Taxonomy", "outputs": [{"description": "debug output showing returned data from OpenTree, even if the method fails", "format": "text", "id": "outstring", "name": "outstring", "type": "string"}, {"description": "three column table of original names, OpenTree TNRS names, and OpenTree taxonomy IDs", "format": "rows", "name": "outTable", "type": "table"}], "script": "#\n# Lookup names using OpenTree Taxonomy\n#\n# description: this analysis expects a single-column input table consisting of scientific names.\n# The analysis consults the OpenTree API and extracts canonical names from the OpenTree taxonomy.\n# The output table consists of three-columns, with the OpenTree name and taxonomy ID columns added to the input. \n#\n# Note:  OpenTree V2 match_names call is being used (development server currently)\n# \n# input: nameTable - single column of scientific names (table:rows format)\n# output: outTable - three column table with OpenTree name and ID appended.\n#\n# revision history:\n# 09/22/14 - CRL modified to guarantee single return only (some anoles returned multiple OttIDs)\n\n\nimport requests\nimport json\n\n# look at the rows of the input table\nmatrixEntries = nameTable['rows']\n\n# find out the title of the columns in this matrix. Assuming this is a single column table\ncolumnHeader = nameTable['fields'][0]\n\noutRows = []\ncount = 0\ninputNameList = []\noutstring = ''\n\nfor matrixEntry in matrixEntries:\n    # build an OTL query to return the matching ottId we want to use to request taxa \n    inputNameList.append(matrixEntry[columnHeader])\n    \n# pack the names into a payload and perform the OpenTree lookup using v3, which has same syntax as v2.\npayload = json.dumps({'names': inputNameList,'do_approximate_matching':doApproximateMatching})\noutstring = outstring+'payload: '+payload\nheaders = {'content-type':'application/json'}\nresp = requests.post('https://api.opentreeoflife.org/v2/tnrs/match_names',data=payload,headers=headers)\noutstring = outstring+' \\nresponse: '+resp.text\n\ntry:\n    returnedrecs = resp.json()['results']\n    # loop through the names queried and returned\n    for index in range(len(returnedrecs)):\n        thisresult = returnedrecs[index]\n        # force return of the first result for each original name\n        candidate = thisresult['matches'][0]\n        outrow = {}\n        outrow[columnHeader] = candidate['search_string']\n        outrow['ottName'] = candidate['ot:ottTaxonName']\n        outrow['ottId'] = candidate['ot:ottId']\n        outRows.append(outrow)\nexcept:\n    outstring = outstring+'\\nerror in OpenTree TNRS lookup. No result returned'\n\n# build the headers for the output table\naugmentedColumnHeaders = [columnHeader, 'ottName','ottId']\n\n# setup the output in table:rows format with the headers explicitly listed\noutTable = {'fields': augmentedColumnHeaders,\n            'rows':  outRows}\n            \n     \n     "}, "visualization": false, "x": 430, "y": 46}, {"girderId": "58e90bf454cdbf7bfe6bea35", "modified": "2017-04-08T16:38:46.420000+00:00", "name": "Return the OpenTree subtree from a node list", "task": {"description": "", "inputs": [{"description": "input matrix containing a column ottid", "format": "rows", "name": "table", "type": "table"}], "mode": "python", "name": "Return the OpenTree subtree from a node list", "outputs": [{"format": "text", "id": "outstring", "name": "debug output string", "type": "string"}, {"format": "newick", "name": "tree", "type": "tree"}, {"description": "quick preview read out of the tree as a newick string", "format": "text", "name": "treeNewickString", "type": "string"}], "script": "import requests\nimport json\n\nrows = table['rows']\nidList = []\nfor i in range(len(rows)):\n    idList.append(rows[i]['ottId'])\n\n# lookup the tree that contains these nodes\n#payload = {\"ottIds\": idList}\n#resp = requests.post('http://api.opentreeoflife.org/treemachine/v1/getDraftTreeSubtreeForNodes',data=payload)\n#tree = str(resp.json()[\"subtree\"])\n\noutstring = ''\n# moving to API v3, same syntax as v2\npayload = json.dumps({\"ott_ids\": idList})\noutstring = outstring+'payload:'+payload\nresp = requests.post('https://api.opentreeoflife.org/v3/tree_of_life/induced_subtree',data=payload)\noutstring = outstring+'\\nresponse:'+resp.text\n\ntry:\n    tree = str(resp.json()[\"newick\"])\nexcept:\n    outstring = outstring+'\\nerror: OpenTree did not return a resulting newick tree'\n    tree = '(B,(A,C,E),D);'\n    \n# tree as a string to preview \ntreeNewickString = tree\n"}, "visualization": false, "x": 673, "y": 48}, {"girderId": "58eb73ce54cdbf7bfe6beb1b", "modified": "2017-04-10T13:47:33.228000+00:00", "name": "Extract EOL traits from Page Link Table", "task": {"description": "Input a table containing taxon names (column header \"name\") and EOL page numbers (column header 'pagenumber') corresponding to EOL pages.  Perform a query for each taxon in the input table and compile a trait matrix for whatever traits are available on the EOL pages.  Missing traits are filled in with empty strings. ", "inputs": [{"format": "rows", "id": "eolTaxonTable", "name": "Table of EOL taxon names and pagenumbers", "type": "table"}], "mode": "python", "name": "Extract EOL traits from Page Link Table", "outputs": [{"description": "A trait matrix compiled from traits on EOL pages", "format": "rows", "id": "traitMatrix", "name": "Trait Matrix from EOL Pages", "type": "table"}, {"format": "text", "id": "debugString", "name": "debugString", "type": "string"}], "script": "\n# parse the incoming matrix, which is assumed to have at least two columns ('name' and 'pagenumber') for the EOL\n# pages we want to use to build a trait list. \n\n# Each taxon has different traits, so we will extract the traits into separate dictionaries for each taxon (each row of matrix). Then we traverse\n# this dictionary of dictionaries afterwards to pull together the final matrix. Also creata a global list of discovered traits\n# across all taxa in the matrix to be the column headers of the final matrix\n\nimport requests\n\ntraitsDictsByNameDictionary = {}\ntraitMatrixUniqueFields = set()\ndebugString = ''\n\n# EOl Taxonomy returns complex names that confuse OpenTree because the taxonomy identifiers are \"informal\". We want to output a cleaned\n# name that will match the cleaned name output from the taxon tables so names can be used to join up traits and tree tips later.  \ndef cleanupEolName(name):\n    # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n    nameTokens = name.split(' ')\n    cleanedName = ' '.join(nameTokens[:2])\n        \n    # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n    # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n    # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n    # These mess up opentree TNRS, so truncate the strings.       \n    if '(' in cleanedName:\n        cleanedName = name[0:name.find(' (')]\n    if ',' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(',')]\n    if '1' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n    return cleanedName\n    \n    \nfor inrow in eolTaxonTable['rows']:\n    # find the page number from the table\n    eolPageNumber = inrow['pagenumber']\n    # now find the traits of the taxon on this page\n    query = 'http://eol.org/api/traits/'+eolPageNumber\n    response = requests.get(query)\n    #debugString += 'trait return:\\n'+response.text\n    jsonReturn = response.json()\n    traitDict = {}\n    for attr in jsonReturn['item']['traits']:\n        # discover each trait name for this taxon and add it to a set (to keep each name only once)\n        traitMatrixUniqueFields.add(attr['predicate'])\n        # store this trait in a dictionary that contains entries for only this taxon\n        traitDict[attr['predicate']] = attr['value'] \n\n    # store the traits discovered for this taxon in the whole matrix dictionary, indexed by name.  This has\n    # a compression affect if a taxon is listed multiple times, it will only appear once in the output matrix. We will lose\n    # information by over-writing, but the matrix will be in traditional form, matching a tree with only one tip per taxon name\n    traitsDictsByNameDictionary[inrow['name']] = traitDict\n\n#print 'columns in matrix:',traitMatrixUniqueFields\n#print 'whole dictionary:',traitsDictsByNameDictionary\n\n# create the output table:rows datatype for the matrix. Put the taxon name first, then the discovered traits\ntraitMatrix = {}\ntraitMatrix['fields'] = list(traitMatrixUniqueFields)\ntraitMatrix['fields'].insert(0,'name')\ntraitMatrix['fields'].insert(1,'eolName')\ntraitMatrix['rows'] = []\n\n\nfor taxon in traitsDictsByNameDictionary.keys():\n    #print 'compiling records for:',taxon\n    row = {}\n    for trait in traitMatrix['fields']:\n        # if this taxon had the trait, copy it, if not, create an empty cell so the matrix is not sparse\n        row[trait] = traitsDictsByNameDictionary[taxon][trait] if trait in traitsDictsByNameDictionary[taxon] else ''\n    # add the taxon name and this taxon's row to the matrix\n    row['name'] = cleanupEolName(taxon)\n    row['eolName'] = taxon\n    traitMatrix['rows'].append(row)\n\n#print 'final matrix:'\n#print traitMatrix\n"}, "visualization": false, "x": 740, "y": 208}, {"girderId": "58e915a654cdbf7bfe6bea77", "modified": "2017-04-08T16:53:58.582000+00:00", "name": "Tree Assign Uniform Edge Weights If Missing", "task": {"description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}], "mode": "python", "name": "Tree Assign Uniform Edge Weights If Missing", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree"}], "script": "nodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \nouttree = tree\nassignEdgeWeightsIfMissing(outtree)\n"}, "visualization": false, "x": 929, "y": 47}, {"girderId": "58e91b9954cdbf7bfe6bea90", "modified": "2017-04-08T17:36:49.288000+00:00", "name": "Convert OpenTree Tip Names to Scientific Names", "task": {"description": "", "inputs": [{"default": {"data": "Tree that has tip names of the form genus_species_ottID", "format": "text", "type": "string"}, "description": "tree with open tree names", "format": "nested", "id": "tree", "name": "tree with Open Tree format names", "type": "tree"}], "mode": "python", "name": "Convert OpenTree Tip Names to Scientific Names", "outputs": [{"format": "nested", "id": "tree_scientific_names", "name": "tree with scientific tip names", "type": "tree"}], "script": "# Convert OpenTree Tip Names to Scientific Names\n#\n# C. Lisle\n# KnowledgeVis, LLC\n# \n# released under Apache 2.0 open-source license\n#\n# This analysis is an algorithm to traverse a tree and rename tips from openTree format (genus_species_ottID) to \"genus species\"\n\n# inputs:\n# tree - a tree (nested format) with shortened names on the tips.  Names are the prefix (up to 9 chars) of the genus name\n\n# output:\n# tree_scientific_names - tree (in nested format) with modified names that match the matrix\n\n# setup global values\ndebugOutput = ''\nnodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \n\n\n\n# convert names from genus_species_ottid to \"genus species\"\ndef fixOpenTreeName(tipname):\n    nameTokens = tipname.split('_')\n    if len(nameTokens)>2:\n        newName = ' '.join(nameTokens[0:2])\n    else:\n        # handle special case where there was no species name, don't splice in an ottID\n        newName = nameTokens[0]\n    return newName\n\n# this is an operation to perform on a taxon node to replace its name.  It is called for each taxon of the tree\ndef taxonOperation(node):\n    # only replace names if they exist.  test first so routine doesn't cause a runtime exception if a name is missing\n    if ('node name' in node['node_data'].keys()):\n        originalName = node['node_data']['node name']\n        newName = fixOpenTreeName(originalName)\n        node['node_data']['node name'] = newName\n\n    \n\n# utility routine to recursively traverse through a phylo tree in nested format.  This traversal starts at the top and recursively traverses the tree.\n# once it finds a taxon, then the routine 'taxonOperation' is called with the taxon node as an argument.  \n\ndef treeTraversal(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            treeTraversal(node)\n    else:\n        #case for a taxa. Run a previously-defined operation on the taxon node\n        taxonOperation(treenode)    \n\n# Top Level Operations \n\n#  setup the structures and go through the tree nodes and replace any names with full names from the reference name list.  The traversal replaces names\n# in place, so when the traversal is done the tree has new node names\n\n\ntreeTraversal(tree)\nassignEdgeWeightsIfMissing(tree)\ntree_scientific_names = tree"}, "visualization": false, "x": 1117, "y": 158}, {"girderId": "58a659fb54cdbf04513b9f4c", "modified": "2017-02-17T02:03:39.556000+00:00", "name": "Create Tree with Image LInks for PhyloPen v2", "task": {"description": "", "inputs": [{"description": "tree to add characters and images to", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}, {"description": "character matrix to add to tree tips", "format": "rows", "id": "matrix", "name": "matrix", "type": "table"}, {"description": "2 column table (taxon, imageURL) for adding image references to taxa", "format": "rows", "id": "image_reference_table", "name": "image_reference_table", "type": "table"}], "mode": "python", "name": "Create Tree with Image LInks for PhyloPen v2", "outputs": [{"description": "tree with trait and image reference data in the named nodes", "format": "nested", "id": "tree_with_traits", "name": "tree_with_traits", "type": "tree"}], "script": "#\n# Take a tree, matrix, and an image reference table as input. Create a nested format\n# tree with image references and attributes attached to the leaves of the tree for display\n# \n# KnowledgeVis, LLC\n# C Lisle\n#\n# update history\n# 2/22/16 - modified for multiple images option per taxon, with text\n\n# inputs:\n# tree - nested format tree with tipnames that match the matrix names\n# matrix - character matrix with names that match the tree tips\n# image_reference_table - 2 column table with tipname and image URL to load the image from\n\n# look through the rows of the image cross reference table.  This format comes from the phenoscape team\n# and has been processed by a previous method to look up the girder item numbers\ndef returnMatchingImageRecord(name):\n    global image_reference_table\n    record = {}\n    for row in image_reference_table['rows']:\n        #print 'looking for ',name,' in ',row\n        if (('taxon' in row) and (name == row['taxon'])):\n            return row['url']\n        if (('species' in row) and (name == row['species'])):\n            return row['url']\n        if (('name' in row) and (name == row['name'])):\n            return row['url']\n    return record\n          \n\n# look through the image matching table.  Three options for taxon name are supported because\n# matrices may not always be indexed the same.  We allow name,species, or taxon:\ndef returnMatchingImageRecordList(name):\n    global image_reference_table\n    records = []\n    for row in image_reference_table['rows']:\n        #print 'looking for ',name,' in ',row\n        if (('taxon' in row) and (name == row['taxon'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['taxon']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n        if (('species' in row) and (name == row['species'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['species']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n        if (('name' in row) and (name == row['name'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['name']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n    return records\n                        \n# look through the rows of the matrix and return a matching entry.  Return the \n# URL record or an empty set (to avoid run-time errors if data doesn't match\n\ndef returnMatchingMatrixRecord(name):\n    global matrix\n    record = {}\n    for row in matrix['rows']:\n        print 'looking for ',name,' in matrix ',row\n        if (('name' in row) and (name == row['name'])):\n            return row\n        if (('species' in row) and (name == row['species'])):\n            return row\n        if (('taxa' in row) and (name == row['taxa'])):\n            print 'found taxon match'\n            return row\n    return record\n            \n    \n# traverse through the tree and add records to the tips from the matrix and the image table\n\ndef addRecordsToTreeTips(treenode):\n    if 'children' in treenode:\n        for node in treenode['children']:\n            addRecordsToTreeTips(node)\n    else:\n        # this is a tip, add matrix and image infor\n        traits = returnMatchingMatrixRecord(treenode['node_data']['node name'])\n        #print 'matching trait record:',traits\n\n        treenode['node_data']['attributes'] = []\n        # add all columns in the character matrix, unless they are the taxa name, since this is already handled in the 'node name'\n        for trait in traits.keys():\n            if trait not in ['species','name','taxa']:\n                treenode['node_data']['attributes'].append({trait: traits[trait]})\n        # add the image attribute to point to the image binary.  There might be more than one image, so \n        # make the entry always be a list. Later we might change these records to have a key tied to a character\n        # to select which image, but just a list initially\n        nodename = treenode['node_data']['node name']\n        # only add an image record if we found an image to match this taxon\n        imageURLs = returnMatchingImageRecordList(treenode['node_data']['node name'])\n        #print 'matching image record:',imageURL\n        for imageRecord in imageURLs:\n            if 'images' in treenode['node_data']:\n                treenode['node_data']['images'].append(imageRecord)\n            else:\n                treenode['node_data']['images'] = []\n                treenode['node_data']['images'].append(imageRecord)\n\n# this routine adds any matrix categories to the record on the root of the tree that specifies\n# what fields are on the nodes.  PhyloPen uses this to parse for attributes to display in the attribute list UI\n\ndef addTraitsToNodeFieldsRecord(treeroot):\n    global matrix\n    #for field in matrix['fields']:\n    #    if field not in ['species','name','taxa']:\n    #        treeroot['node_fields'].append(field)\n    # indicate an attributes record\n    treeroot['node_fields'].append('attributes')\n    # indicate there could be an images record as well\n    treeroot['node_fields'].append('images')\n\n# ---- top level -----\n\ntree_with_traits = tree\naddRecordsToTreeTips(tree_with_traits)\naddTraitsToNodeFieldsRecord(tree_with_traits)\n\n\n\n"}, "visualization": false, "x": 1278, "y": 320}]}}, "name": "WF build PhyloPen Dataset from EOL", "size": 0, "updated": "2017-12-15T03:03:28.420000+00:00"}