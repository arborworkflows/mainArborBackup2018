{"description": "Input a table containing taxon names (column header \"name\") and EOL page numbers (column header 'pagenumber') corresponding to EOL pages.  Perform a query for each taxon in the input table and compile a trait matrix for whatever traits are available on the EOL pages.  Missing traits are filled in with empty strings. ", "inputs": [{"format": "rows", "id": "eolTaxonTable", "name": "Table of EOL taxon names and pagenumbers", "type": "table"}], "mode": "python", "name": "Extract EOL traits from Page Link Table", "outputs": [{"description": "A trait matrix compiled from traits on EOL pages", "format": "rows", "id": "traitMatrix", "name": "Trait Matrix from EOL Pages", "type": "table"}, {"format": "text", "id": "debugString", "name": "debugString", "type": "string"}], "script": "\n# parse the incoming matrix, which is assumed to have at least two columns ('name' and 'pagenumber') for the EOL\n# pages we want to use to build a trait list. \n\n# Each taxon has different traits, so we will extract the traits into separate dictionaries for each taxon (each row of matrix). Then we traverse\n# this dictionary of dictionaries afterwards to pull together the final matrix. Also creata a global list of discovered traits\n# across all taxa in the matrix to be the column headers of the final matrix\n\nimport requests\n\ntraitsDictsByNameDictionary = {}\ntraitMatrixUniqueFields = set()\ndebugString = ''\n\n# EOl Taxonomy returns complex names that confuse OpenTree because the taxonomy identifiers are \"informal\". We want to output a cleaned\n# name that will match the cleaned name output from the taxon tables so names can be used to join up traits and tree tips later.  \ndef cleanupEolName(name):\n    # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n    nameTokens = name.split(' ')\n    cleanedName = ' '.join(nameTokens[:2])\n        \n    # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n    # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n    # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n    # These mess up opentree TNRS, so truncate the strings.       \n    if '(' in cleanedName:\n        cleanedName = name[0:name.find(' (')]\n    if ',' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(',')]\n    if '1' in cleanedName:\n        cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n    return cleanedName\n    \n    \nfor inrow in eolTaxonTable['rows']:\n    # find the page number from the table\n    eolPageNumber = inrow['pagenumber']\n    # now find the traits of the taxon on this page\n    query = 'http://eol.org/api/traits/'+eolPageNumber\n    response = requests.get(query)\n    #debugString += 'trait return:\\n'+response.text\n    try:\n        jsonReturn = response.json()\n        traitDict = {}\n        for attr in jsonReturn['item']['traits']:\n            # discover each trait name for this taxon and add it to a set (to keep each name only once)\n            traitMatrixUniqueFields.add(attr['predicate'])\n            # store this trait in a dictionary that contains entries for only this taxon\n            traitDict[attr['predicate']] = attr['value'] \n\n        # store the traits discovered for this taxon in the whole matrix dictionary, indexed by name.  This has\n        # a compression affect if a taxon is listed multiple times, it will only appear once in the output matrix. We will lose\n        # information by over-writing, but the matrix will be in traditional form, matching a tree with only one tip per taxon name\n        traitsDictsByNameDictionary[inrow['name']] = traitDict\n    except:\n        # ignore empty responses or error responses from EOL.  Recently, we have been receiving code 429 (too many requests)\n        pass\n\n#print 'columns in matrix:',traitMatrixUniqueFields\n#print 'whole dictionary:',traitsDictsByNameDictionary\n\n# create the output table:rows datatype for the matrix. Put the taxon name first, then the discovered traits\ntraitMatrix = {}\ntraitMatrix['fields'] = list(traitMatrixUniqueFields)\ntraitMatrix['fields'].insert(0,'name')\ntraitMatrix['fields'].insert(1,'eolName')\ntraitMatrix['rows'] = []\n\n\nfor taxon in traitsDictsByNameDictionary.keys():\n    #print 'compiling records for:',taxon\n    row = {}\n    for trait in traitMatrix['fields']:\n        # if this taxon had the trait, copy it, if not, create an empty cell so the matrix is not sparse\n        row[trait] = traitsDictsByNameDictionary[taxon][trait] if trait in traitsDictsByNameDictionary[taxon] else ''\n    # add the taxon name and this taxon's row to the matrix\n    row['name'] = cleanupEolName(taxon)\n    row['eolName'] = taxon\n    traitMatrix['rows'].append(row)\n\n#print 'final matrix:'\n#print traitMatrix\n"}