{"_id": "5a09a05454cdbf0a23597561", "_modelType": "item", "baseParentId": "58a659bc54cdbf04513b9f48", "baseParentType": "collection", "created": "2017-11-13T13:38:28.074000+00:00", "creatorId": "575874fe54cdbf51760708f3", "description": "", "folderId": "58a659bc54cdbf04513b9f49", "meta": {"analysis": {"description": "Take a string query from a user for a clade or organism, such as \"bears\", \"ursidae\", \"oysters\", etc.  and return a tree containing all the returns, according to the Encylopedia of Life search interface.  The trees returned are likely to contain the desired organisms as well as \"false positives\", such as returning a \"catfish\" when \"cat\" was the search term. This could, itself, be a helpful educational side-effect. ", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "query", "name": "animal or plant name to look for", "type": "string"}], "mode": "python", "name": "Build Tree from EOL query", "outputs": [{"description": "a printable string which is a depth-first traversal of the tree node names", "format": "text", "id": "outstring", "name": "String output of tree traversal", "type": "string"}, {"description": "tree in nested format, created through EOL hierarchy API calls", "format": "nested", "id": "outTree", "name": "Tree Extracted from EOL hierarchy", "type": "tree"}, {"description": "A count of the number of nodes in the returned tree.  Output as a string", "format": "text", "id": "treeNodeCount", "name": "Number of nodes in the tree", "type": "string"}], "script": "#\n# access the EOL API to find matching taxa/subtaxa that match a query term\n# input: query (string)\n# outputs: tree - output a tree created from accessing the EOL pages and hierarchies API\n\nimport requests\nfrom lxml import html\nimport json\nimport time\n\n\n# global variables shared and updated by multiple routines during this method\n\nnodes = {}\nwasInTreeCount = 0\noutstring = ''\noutTree = {}\nfirstTime = True\n\n# update the 'children' reference to include a new child.  This routine returns the \n# modified parent node\n\ndef addChildNodeToParent(node,parent):\n    # if this node is not already a child, then add it in the children dictionary\n    if node['taxonID'] not in parent['children'].keys():\n        parent['children'][node['taxonID']] = node['taxonID']\n    else:\n        #if this node has already been added, then do nothing\n        pass\n    return parent\n\n\n# add a single node to the tree.  This checks to see if the parent is already in the tree\n# and updates the children links.  This is designed to be callable repeately with the same node\n# but the node will only be entered in the tree once.  The EOL APIs return a list from a node ID\n# all the way back to the root of the TOL, so higher taxon will be encountered multiple times during\n# the construction of a tree. \n\ndef addNodeToTree(thisNode):\n    global nodes\n    global wasInTreeCount\n    #print 'attempting to add',thisNode['taxonID']\n    if thisNode['taxonID'] not in nodes.keys():\n        #print 'not in tree'\n        # first time we've seen this node, so add it without children\n        thisNode['children'] = {}\n        nodes[thisNode['taxonID']] = thisNode\n    else: \n        #print 'was in tree'\n        wasInTreeCount += 1\n        # we have seen this node before because each node is entered only once\n        pass\n    # add a child link to our parent node by update the parent node.  This will fail on the first\n    # node added, so test that the parent is in the accumulator already\n\n    if thisNode['parentNameUsageID'] in nodes.keys():\n        nodes[thisNode['parentNameUsageID']] =   addChildNodeToParent(thisNode,nodes[thisNode['parentNameUsageID']])\n\n\n# add a leaf node and all its ancestors to the tree.  This is called each time the EOL hierarchy returns a path from the \n# TOL root to a specific OTU.  All the nodes along the path are added to the tree in order from higher taxon to lower tacon\n\ndef addNodeAndAncestorsToTree(node, ancestors):\n    global nodes\n    lastAncestor = ''\n    #loop through the ancestors and add them to the accumulator\n    for thisNode in ancestors:\n        addNodeToTree(thisNode)\n        lastAncestor = thisNode\n    #  set the parent to the taxonID of the last (most recent) ancestor\n    # if there were no ancestors in the list, then don't add this node\n    if lastAncestor != '':\n        # fix since the leaves have their taxonID listed in a different place, so copy over \n        node['taxonID'] = node['identifier']\n        # link this leaf to the last ancestor returned in the list\n        node['parentNameUsageID'] = lastAncestor['taxonID']\n        addNodeToTree(node)\n    else:\n        print 'add node called with null node. ignoring'\n  \n# once the nodes have all been loaded in the tree, one of them should have a parent which has taxonID=0 (since it \n# has no parent.  This will be the root, so scan throgh the nodes and return the index \n \ndef findRootTaxonID():\n    global nodes\n    # find root\n    root = -1\n    for key in nodes.keys():\n        if nodes[key]['parentNameUsageID'] == 0:\n            root = key\n            break\n    return root\n\n\n# get rid of any words past the first two and suppress following punctuation\ndef cleanTaxonName(name):\n    spaceSplit = name.split(' ')\n    if len(spaceSplit)>1:\n        clean = spaceSplit[0].capitalize() + ' '+ spaceSplit[1].lower()\n    else:\n        clean = spaceSplit[0].capitalize()\n    return clean.replace(',','')\n    \n# this routine prints out a single node in the tree with an indent according to the tree level. It is designed\n# to be called during a depth-first traversal of the tree.  Output goes to standard out via python's print statement\n# and/or is concatenated to an outputstring for output to other workflow steps or review. \n\ndef outputNode(node,level):\n    global outstring\n    indentString=''\n    for i in range(0,level):\n        indentString += ' '\n    #print indentString,node['scientificName']\n    outstring += indentString\n    outstring += cleanTaxonName(node['scientificName'])\n    outstring += '\\n'\n    \n    \n# this prints out the tree by looking for the root (with parentID=0) and then conducts a depth-first traversal\n# of the tree, outputting nodes as they are encountered.  \n\ndef printTree():\n    global nodes\n    # find root\n    root = findRootTaxonID()\n    #print '----------- tree -------'\n    traverseNode(nodes[root],0)\n    \n    \n# This method is called repeatedly for each node in the tree during a tree traversal.  The node information is \n# output and the traversal continues with any children nodes below the current node. \n    \ndef traverseNode(node,level):\n    global nodes\n    # start at the root\n    outputNode(node,level)\n    for child in node['children']:\n        traverseNode(nodes[child],level+1)\n        \n# -- create tree:nested output is based on the three string output routines above with only tiny modifications to handle \n# -- changes to the global outTree data structure\n        \ndef outputNodeNested(parent,node,level):\n    global firstTime\n    parent = {}\n    parent['node_data'] = {}\n    parent['node_data']['node name'] = cleanTaxonName(node['scientificName'])\n    parent['node_data']['nodeid'] = node['taxonID']\n    parent[\"edge_fields\"] = [\"weight\"]\n    parent[\"node_fields\"] = [\"node name\", \"nodeid\"]\n    parent['children'] = []\n    # if this is not the root, then include a weight one edge\n    if firstTime:\n        firstTime = False\n        parent[\"edge_fields\"] = [\"weight\"]\n        parent[\"node_fields\"] = [\"node name\", \"nodeid\"]\n    else:\n        parent['edge_data'] = {'weight':1.0}\n    return parent\n\n    \n    \n# this prints out the tree by looking for the root (with parentID=0) and then conducts a depth-first traversal\n# of the tree, outputting nodes as they are encountered.  \n\ndef printTreeNested():\n    global nodes\n    global outTree\n    # find root\n    root = findRootTaxonID()\n    #print '----------- tree -------'\n    outTree = outputNodeNested(outTree,nodes[root],0)\n    for child in nodes[root]['children']:\n        outTree = traverseNodeNested(outTree,nodes[root],0)\n    \n       \n# This method is called repeatedly for each node in the tree during a tree traversal.  The node information is \n# output and the traversal continues with any children nodes below the current node. \n    \ndef traverseNodeNested(parent,node,level):\n    global nodes\n    # start at the root\n    parent = outputNodeNested(parent,node,level)\n    for child in node['children']:\n        parent['children'].append(traverseNodeNested(parent,nodes[child],level+1))\n    return parent\n\n\ndef throttleWebAccess():\n    time.sleep(0.51)        \n        \n#----------------------------------------------------\n# Beginning of the main loop of the method\n#----------------------------------------------------\n\n#query = 'Bears'\n#query = 'heliconia'\n#query = 'Felis catus Linnaeus'\n#query = 'carnivore'\n#query = 'oyster'\n\n# pass the query string to the EOL search API to get back a table of related pages\n\neolquery = 'http://eol.org/api/search/1.0.json?q='+query\nresponse = requests.get(eolquery)\njsonReturn = response.json()\nthrottleWebAccess()\n\n# go through each entry and find the corresponding EOL page for this search return.  The \n# search returns are the leaves of the tree, so find the EOL pages. Then lookup the taxonID\n# and make a hierarchy call to get the path from the root of the TOL to this leaf.  Add these\n# paths one at a time to build a tree that contains all the search returns.\n\nfor rec in jsonReturn['results']:\n    print rec['title'],rec['id']\n    \n    query = str(rec['id']) \n    pages = requests.put('http://eol.org/api/pages/1.0.json/?id='+query)\n    \n    try:\n        pagesJson = pages.json()\n        throttleWebAccess()\n    \n        # now loop through the taxonConcepts (tc) returned as pages and retrieve their paths from the root of the TOL\n        for tc in pagesJson['taxonConcepts']:\n        \n            # EOL uses multiple taxonomies instead of creating a single one, such as what the OpenTree is doing.  \n            # for this analysis, we pick one and deal with the strenghts and weaknesses of that particular hierarchy.\n            # It was observed that NCBI had more levels of depth, but seemed more taxonomic, with less readable content.\n            # Since one of the main applications for this is education, ITIS seems to offer a simpler, denser hierarchy.\n            # We select only the entries corresponding to the hierarchy of choice and look them up to add the paths\n            # to the output tree. \n        \n            #if tc[\"nameAccordingTo\"] == 'NCBI Taxonomy':\n            if tc[\"nameAccordingTo\"] ==  'Integrated Taxonomic Information System (ITIS)':\n                #print tc['taxonRank'],tc['identifier']\n                id = str(tc['identifier']) \n                eolquery = 'http://eol.org/api/hierarchy_entries/1.0.json/?id='+id\n                hierarchy = requests.get(eolquery)\n                throttleWebAccess()\n                hierJson = hierarchy.json()\n                addNodeAndAncestorsToTree(tc,hierJson['ancestors'])\n                break\n    except:\n        pass\n                \n\n# prepare the output\ntreeNodeCount = str(len(nodes.keys()))\nprint 'number of nodes in the tree:',treeNodeCount\n\nprintTree() \nprintTreeNested()\n        \n        \n        \n        \n        \n    "}}, "name": "Build Tree from EOL query", "size": 0, "updated": "2018-01-14T00:17:15.198000+00:00"}