{"description": "", "inputs": [{"default": {"data": "Ursus", "format": "text", "type": "string"}, "description": "type the name of an animal/plant or group to search for (e.g. 'scorpions', 'bears', 'ursidae')", "format": "text", "id": "query", "name": "animal or plant name to look for", "type": "string"}, {"default": {"data": "5", "format": "text", "type": "string"}, "description": "limit of how many images will be added to the image table for each taxon", "format": "number", "id": "maxImagesPerTaxon", "name": "max number of images to return per taxon", "type": "number"}], "mode": "python", "name": "Build Matrix from EOL query", "outputs": [{"description": "table of name and EOL pages discovered to match a query", "format": "rows", "id": "matrix", "name": "matrix of taxa discovered on EOL", "type": "table"}, {"description": "a two-column table with species name and extra images, up to the max number of images, each image in a separate row", "format": "rows", "id": "imageLinks", "name": "Image Link table", "type": "table"}], "script": "#\n# access the EOL API to find matching taxa/subtaxa that match a query term\n# input: query (string)\n# outputs: matrix - a single entry for each species, along with its EOL link and an image\n# imageLinks: a two column table, with a row for every image discovered.  The schema is 'name','url'\n# maxImagesPerTaxon: an integer specifying how many images to return for a single species\n\nimport requests\n#import string\nfrom lxml import html\n\neolquery = 'http://eol.org/api/search/1.0.json?q='+query\nresponse = requests.get(eolquery)\njsonReturn = response.json()\n\n# now go through the results returned and pull out the name and EOL page number for each \n# search return (taxon) which matched.\n\n# start with an empty output matrix\nmatrix = {}\nmatrix['fields'] = ['name','pagenumber','page','image']\nmatrix['rows'] = []\n\n# create an empty image url table\nimageLinks = {}\nimageLinks['fields'] = ['name','url']\nimageLinks['rows'] = []\n\n\n# get rid of any words past the first two and suppress following punctuation, so names like 'Carnivora Bowdich, 1821'\n# will be output as 'Carnivora bowdich'.  Capitalization is enforced for first word and lowercase on second word,\n# since this is the Latin name (scientific name) convention\n\n# get rid of any words past the first two and suppress following punctuation\ndef cleanTaxonName(name):\n    spaceSplit = name.split(' ')\n    if len(spaceSplit)>1:\n        clean = spaceSplit[0].capitalize() + ' '+ spaceSplit[1].lower()\n    else:\n        clean = spaceSplit[0].capitalize()\n    return clean.replace(',','')\n\n# some duplicates return from the search, so put the names in a set and check\n# that only unique entries are added to the table\nnameSet = set()\n\nfor res in jsonReturn['results']:\n    name = res['title']\n    link = res['link']\n    print '***Exploring name:',name\n    \n    # many informal taxonomies with creator names , pass only the first two words in the taxonomic name\n    cleanedName = cleanTaxonName(name)\n    print 'name cleaned to:',cleanedName\n    \n    # test if we have seen this taxon before\n    if cleanedName not in nameSet:\n        nameSet.add(cleanedName)\n\n      \n        #nameTokens = name.split(' ')\n        #cleanedName = ' '.join(nameTokens[:2])\n        \n        # most (all?) cases are fixed by truncating to two words, but just to be sure, these tests remain:\n        # many of the taxonomy names have a parenthetic qualifier on them, for example: (Linnaeus, 1766).\n        # to indicate which taxonomy was used. Sometimes there is a comma and year after a name, example: 'Lynx lynx, 1973'.\n        # These mess up opentree TNRS, so truncate the strings. \n        \n        #if '(' in cleanedName:\n        #    cleanedName = name[0:name.find(' (')]\n        #if ',' in cleanedName:\n        #    cleanedName = cleanedName[0:cleanedName.find(',')]\n        #if '1' in cleanedName:\n        #    cleanedName = cleanedName[0:cleanedName.find(' 1')+1]\n            \n        # store in output row; the cleaning operation is largely redundant, but this same routine is used in the \n        # \"tree from matrix\" method, so we want to make sure the matrix names and tip names match as much as practical\n        taxaRow = {}\n        taxaRow['name'] =  cleanedName\n    \n        #find the page number and images for this taxon.  We extract the page number from the page link\n        questionMarkPosition = link.find('?')\n        eolPageNumber = link[15:questionMarkPosition]\n        #print 'page number:',eolPageNumber\n        taxaRow['pagenumber'] = eolPageNumber\n        taxaRow['page'] = link\n    \n        # now find the images on the corresponding taxon media page\n        mediaQuery = 'http://eol.org/pages/'+eolPageNumber+'/media'\n        response = requests.get(mediaQuery)\n        jsonReturn = response.content\n        tree = html.fromstring(response.content)\n        #print jsonReturn\n        images = tree.xpath('//img/@src')\n        names = tree.xpath('//img/@alt')\n            \n        # use sets to remove duplicates.  This assumes the names and images duplicate at the same time. This could\n        # be a risky assumption. \n        uniqueImages = set(images)\n        uniqueNames = set(names)\n        \n        # return only the first five in the list. Use Max function to \n        # Return fewer images if there were less than the specified max available\n        for index in range(min(len(uniqueImages),maxImagesPerTaxon)):\n            imageRow = {}\n            #url = uniqueImages[index]\n            # have to extract from sets, not use an index\n            url = uniqueImages.pop()\n            imageRow['name'] = taxaRow['name']\n            imageRow['url'] = url\n            imageLinks['rows'].append(imageRow)\n            if index == 0:\n                taxaRow['image'] = url\n    \n        # add this taxa to the output table        \n        matrix['rows'].append(taxaRow)\n    \n        \n        \n        \n        \n        \n        \n    "}