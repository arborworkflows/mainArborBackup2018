{"connections": [{"input": "maxImagesPerTaxon", "input_step": "SpongeGuide Extract Image and Morph Tables", "name": "maxImagesPerTaxon"}, {"input": "nameTable", "input_step": "Lookup names using OpenTree Taxonomy", "output": "morphmat", "output_step": "SpongeGuide Extract Image and Morph Tables"}, {"input": "table", "input_step": "Return the OpenTree subtree from a node list", "output": "outTable", "output_step": "Lookup names using OpenTree Taxonomy"}, {"input": "tree", "input_step": "Assign Tree Branch Branch Lengths If Missing", "output": "tree", "output_step": "Return the OpenTree subtree from a node list"}, {"input": "originalTable", "input_step": "Replace Matrix Names with OpenTree Composite Names", "output": "morphmat", "output_step": "SpongeGuide Extract Image and Morph Tables"}, {"input": "ottIdTable", "input_step": "Replace Matrix Names with OpenTree Composite Names", "output": "outTable", "output_step": "Lookup names using OpenTree Taxonomy"}, {"input": "originalTable", "input_step": "Replace Matrix Names with OpenTree Composite Names 1", "output": "imagetable", "output_step": "SpongeGuide Extract Image and Morph Tables"}, {"input": "ottIdTable", "input_step": "Replace Matrix Names with OpenTree Composite Names 1", "output": "outTable", "output_step": "Lookup names using OpenTree Taxonomy"}, {"input": "tree", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "outtree", "output_step": "Assign Tree Branch Branch Lengths If Missing"}, {"input": "matrix", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "tableWithOpenTreeNames", "output_step": "Replace Matrix Names with OpenTree Composite Names"}, {"input": "image_reference_table", "input_step": "Create Tree with Image LInks for PhyloPen v2", "output": "tableWithOpenTreeNames", "output_step": "Replace Matrix Names with OpenTree Composite Names 1"}, {"input": "tree", "input_step": "Convert OpenTree Tip Names to Scientific Names", "output": "tree_with_traits", "output_step": "Create Tree with Image LInks for PhyloPen v2"}, {"name": "tree with traits and pictures", "output": "tree_scientific_names", "output_step": "Convert OpenTree Tip Names to Scientific Names"}], "description": "", "inputs": [{"default": {"data": "6", "format": "text", "type": "string"}, "description": "how many images to include per taxon", "format": "number", "id": "maxImagesPerTaxon", "name": "maxImagesPerTaxon", "type": "number", "x": 19, "y": 112}], "mode": "workflow", "name": "WF spongeGuide to PhyloPen", "outputs": [{"description": "A workflow that pulls all taxa, traits, and pictures from SpongeGuide, matches the names using OTL TNRS and pulls an inferred tree from OTL.  Suitable for viewing by PhyloPen", "format": "nested", "id": "tree with traits and pictures", "name": "tree with traits and pictures", "type": "tree", "x": 1640, "y": 363}], "steps": [{"girderId": "59176a4e54cdbf1105584573", "modified": "2017-05-14T22:34:47.731000+00:00", "name": "SpongeGuide Extract Image and Morph Tables", "task": {"description": "", "inputs": [{"default": {"data": "6", "format": "text", "type": "string"}, "description": "how many images to include per taxon", "format": "number", "id": "maxImagesPerTaxon", "name": "maxImagesPerTaxon", "type": "number"}], "mode": "python", "name": "SpongeGuide Extract Image and Morph Tables", "outputs": [{"format": "rows", "id": "morphmat", "name": "morphmat", "type": "table"}, {"format": "rows", "id": "imagetable", "name": "imagetable", "type": "table"}], "script": "import requests\nfrom lxml import html\n\n# create empty output tables\nmorphmat = {}\nmorphmat['fields'] = ['name','Color','Morphology','Consistency','Location','Description']\n#morphmat['fields'] = ['name','Attributes','Description']\nmorphmat['rows'] = []\n\nimagetable = {}\nimagetable['fields'] = ['name','url']\nimagetable['rows'] = []\n\n# now get the list of all taxa from spongeguide\nresp = requests.get('http://spongeguide.org/ajaxtaxalist.php?&searchtype=5&taxa=')\n#print resp.text\nalltaxa = resp.json()['data']\n\n# work through the taxa, filling the morph matrix and the image table with the records\n# found by scraping the website contents\n\nfor taxon in alltaxa:\n    url = 'http://spongeguide.org/'+taxon[12]\n    page = requests.get(url)\n    tree = html.fromstring(page.content)\n    namestr = str(tree.xpath('//title/text()'))\n    genusSpecies = namestr[namestr.find(' ')+1:-3]\n    \n    morphrow = {}\n    # now extract morphology\n    morphrow['name'] = genusSpecies\n    morphrow['Description'] = taxon[16]\n    \n    # prevent species with fragments of quotes from being output\n    if (genusSpecies.find('\"') < 0):\n\n        # extract the separate attributes from the single string returned by SpongeGuide. This custom parsing is\n        # to split out the separate attributes, some records don't have entries, so we have to look for the \n        # len(entry) == 0 to avoid a run-time error.\n        attribs = taxon[18].split(',')\n        categories = ['Color','Morphology','Consistency','Location']\n        current = -1\n        att_dict = {}\n        for cat in categories:\n            att_dict[cat] = ''\n        # the time when there is no word at all or no space before the word is when the next true attribute begins\n        for word in attribs:\n            # skip past empty attribute entries\n            if len(word)==0:\n                current += 1\n            elif word[0] != ' ':\n                current += 1\n            att_dict[categories[current]]  += word + ' '\n        # copy from the dictonary into the morphology table row\n        for cat in categories:\n            morphrow[cat] = att_dict[cat]\n        \n        morphmat['rows'].append(morphrow)\n    \n    # fetch the images associated with this taxon\n        imageCount = 0\n        images = tree.xpath('//img')\n        for img in images:\n            if imageCount> maxImagesPerTaxon:\n                break;\n            srctext = img.get('src')\n            # mask off the logos and other images; pass only the main content images\n            if srctext[0:4] == 'mini':\n                imagerow = {}\n                imagerow['name'] = genusSpecies\n                url = 'http://spongeguide.org/'+srctext\n                imagerow['url'] = url\n                imagetable['rows'].append(imagerow)\n                imageCount += 1\n\n    \n    \n"}, "visualization": false, "x": 301, "y": 197}, {"girderId": "58e804e254cdbf7bfe6be9d4", "modified": "2017-04-08T15:14:25.265000+00:00", "name": "Lookup names using OpenTree Taxonomy", "task": {"description": "", "inputs": [{"default": {"data": "'True'", "format": "text", "type": "string"}, "description": "Should OpenTree use fuzzy matching (noticably slower, but better matching). Use 'True' or 'False' strings", "format": "text", "id": "doApproximateMatching", "name": "Allow Approximate Matching", "type": "string"}, {"description": "single column table of scientific names", "format": "rows", "name": "nameTable", "type": "table"}], "mode": "python", "name": "Lookup names using OpenTree Taxonomy", "outputs": [{"description": "debug output showing returned data from OpenTree, even if the method fails", "format": "text", "id": "outstring", "name": "outstring", "type": "string"}, {"description": "three column table of original names, OpenTree TNRS names, and OpenTree taxonomy IDs", "format": "rows", "name": "outTable", "type": "table"}], "script": "#\n# Lookup names using OpenTree Taxonomy\n#\n# description: this analysis expects a single-column input table consisting of scientific names.\n# The analysis consults the OpenTree API and extracts canonical names from the OpenTree taxonomy.\n# The output table consists of three-columns, with the OpenTree name and taxonomy ID columns added to the input. \n#\n# Note:  OpenTree V2 match_names call is being used (development server currently)\n# \n# input: nameTable - single column of scientific names (table:rows format)\n# output: outTable - three column table with OpenTree name and ID appended.\n#\n# revision history:\n# 09/22/14 - CRL modified to guarantee single return only (some anoles returned multiple OttIDs)\n\n\nimport requests\nimport json\n\n# look at the rows of the input table\nmatrixEntries = nameTable['rows']\n\n# find out the title of the columns in this matrix. Assuming this is a single column table\ncolumnHeader = nameTable['fields'][0]\n\noutRows = []\ncount = 0\ninputNameList = []\noutstring = ''\n\nfor matrixEntry in matrixEntries:\n    # build an OTL query to return the matching ottId we want to use to request taxa \n    inputNameList.append(matrixEntry[columnHeader])\n    \n# pack the names into a payload and perform the OpenTree lookup using v3, which has same syntax as v2.\npayload = json.dumps({'names': inputNameList,'do_approximate_matching':doApproximateMatching})\noutstring = outstring+'payload: '+payload\nheaders = {'content-type':'application/json'}\nresp = requests.post('https://api.opentreeoflife.org/v2/tnrs/match_names',data=payload,headers=headers)\noutstring = outstring+' \\nresponse: '+resp.text\n\ntry:\n    returnedrecs = resp.json()['results']\n    # loop through the names queried and returned\n    for index in range(len(returnedrecs)):\n        thisresult = returnedrecs[index]\n        # force return of the first result for each original name\n        candidate = thisresult['matches'][0]\n        outrow = {}\n        outrow[columnHeader] = candidate['search_string']\n        outrow['ottName'] = candidate['ot:ottTaxonName']\n        outrow['ottId'] = candidate['ot:ottId']\n        outRows.append(outrow)\nexcept:\n    outstring = outstring+'\\nerror in OpenTree TNRS lookup. No result returned'\n\n# build the headers for the output table\naugmentedColumnHeaders = [columnHeader, 'ottName','ottId']\n\n# setup the output in table:rows format with the headers explicitly listed\noutTable = {'fields': augmentedColumnHeaders,\n            'rows':  outRows}\n            \n     \n     "}, "visualization": false, "x": 574, "y": 104}, {"girderId": "58e90bf454cdbf7bfe6bea35", "modified": "2017-04-08T16:38:46.420000+00:00", "name": "Return the OpenTree subtree from a node list", "task": {"description": "", "inputs": [{"description": "input matrix containing a column ottid", "format": "rows", "name": "table", "type": "table"}], "mode": "python", "name": "Return the OpenTree subtree from a node list", "outputs": [{"format": "text", "id": "outstring", "name": "debug output string", "type": "string"}, {"format": "newick", "name": "tree", "type": "tree"}, {"description": "quick preview read out of the tree as a newick string", "format": "text", "name": "treeNewickString", "type": "string"}], "script": "import requests\nimport json\n\nrows = table['rows']\nidList = []\nfor i in range(len(rows)):\n    idList.append(rows[i]['ottId'])\n\n# lookup the tree that contains these nodes\n#payload = {\"ottIds\": idList}\n#resp = requests.post('http://api.opentreeoflife.org/treemachine/v1/getDraftTreeSubtreeForNodes',data=payload)\n#tree = str(resp.json()[\"subtree\"])\n\noutstring = ''\n# moving to API v3, same syntax as v2\npayload = json.dumps({\"ott_ids\": idList})\noutstring = outstring+'payload:'+payload\nresp = requests.post('https://api.opentreeoflife.org/v3/tree_of_life/induced_subtree',data=payload)\noutstring = outstring+'\\nresponse:'+resp.text\n\ntry:\n    tree = str(resp.json()[\"newick\"])\nexcept:\n    outstring = outstring+'\\nerror: OpenTree did not return a resulting newick tree'\n    tree = '(B,(A,C,E),D);'\n    \n# tree as a string to preview \ntreeNewickString = tree\n"}, "visualization": false, "x": 850, "y": 142}, {"girderId": "590b4b1e54cdbf7a5dff8634", "modified": "2017-05-04T15:39:11.050000+00:00", "name": "Assign Tree Branch Branch Lengths If Missing", "task": {"description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}], "mode": "python", "name": "Assign Tree Branch Branch Lengths If Missing", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree"}], "script": "nodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \nouttree = tree\nassignEdgeWeightsIfMissing(outtree)\n"}, "visualization": false, "x": 1091, "y": 167}, {"girderId": "5918ca4454cdbf1105584619", "modified": "2017-05-14T21:21:08.647597+00:00", "name": "Replace Matrix Names with OpenTree Composite Names", "task": {"inputs": [{"format": "rows", "name": "originalTable", "type": "table"}, {"format": "rows", "name": "ottIdTable", "type": "table"}], "mode": "python", "name": "Replace Matrix Names with OpenTree Composite Names", "outputs": [{"format": "rows", "name": "tableWithOpenTreeNames", "type": "table"}, {"format": "text", "name": "debugstring", "type": "string"}], "script": "#\n# input: originalTable\n# input: ottIdTable\n#\n\n# allowed name field columns\nallowedSpeciesColumnNames = ['species','name','Species','x','scientific name','Scientific Name']\n\n# get variables pointing to the original table that contains all trait columns \ninfields = originalTable['fields']\ninrows = originalTable['rows']\n# get a pointer to the 3 column name lookup table (with original name, ottName, ottId fields)\nottrows = ottIdTable['rows']\n\n# find a matching column for the species names.  We have to be indirect because the column could have several\n# headings.  Find a match and then return the index of the match\n\ndef findMatchingOttTableRow(originalName):\n    global ottrows,inrows\n    matched = False\n    index = -1\n    for rownum in range(len(ottrows)):\n        for attrib in ottrows[rownum]:\n            if attrib in allowedSpeciesColumnNames:\n                if (ottrows[rownum][attrib]).lower() == originalName.lower():\n                    index = rownum\n                    break\n    return index\n    \noutrows = []\ndebugstring = ''\n\ndef findIndexOfNameInFields(fields):\n    global allowedSpeciesColumnNames\n    index = 0\n    for field in fields:\n        if field in allowedSpeciesColumnNames:\n            break\n        index += 1\n    return index\n    \n\n# go through the table a row at a time, since there might be less rows in the ottTable, lets use it as the index\nfor rownum in range(len(inrows)):\n    outrow = {}\n    matched = False\n    # look at each column in the table\n    for field in inrows[rownum]:\n        # if this is the name column, replace the orignal name with a name of the form ottGenus_ottSpecies_ott<ottId>\n        if field in allowedSpeciesColumnNames:\n            ottIndex = findMatchingOttTableRow(inrows[rownum][field])\n            if ottIndex >= 0:\n                debugstring += 'name:'+inrows[rownum][field]+' matched to index '+str(ottIndex)+'\\n'\n                newname = (ottrows[ottIndex]['ottName']).replace(\" \",\"_\")+\"_ott\"+str(ottrows[ottIndex]['ottId'])\n                outrow[field] = newname\n                matched = True\n        else:\n            # if not the name field, copy data through and preserve name\n            outrow[field] = inrows[rownum][field]\n    # finished processing all fields, so add this output row, but only if it matched the ottTable\n    if matched == True:\n        outrows.append(outrow)\n        \n# create the output column list\noutcolumns = []\nfor attrib in outrows[0]:\n    outcolumns.append(attrib)\n    \n# now reorder the field list so the species names are in the front\nspeciesIndex = findIndexOfNameInFields(outcolumns)\nif speciesIndex != 0:\n    #switch the names with the current first attribute to put species names first\n    tempSaveAttribute = outcolumns[0]\n    currentSpeciesColumnName = outcolumns[speciesIndex]\n    outcolumns[0] = currentSpeciesColumnName\n    outcolumns[speciesIndex] = tempSaveAttribute\n\n    \ntableWithOpenTreeNames = {\n    'fields': outcolumns,\n    'rows': outrows}\n    \n    "}, "visualization": false, "x": 916, "y": 320}, {"girderId": "5918ca4454cdbf1105584619", "modified": "2017-05-14T21:21:08.647597+00:00", "name": "Replace Matrix Names with OpenTree Composite Names 1", "task": {"inputs": [{"format": "rows", "name": "originalTable", "type": "table"}, {"format": "rows", "name": "ottIdTable", "type": "table"}], "mode": "python", "name": "Replace Matrix Names with OpenTree Composite Names", "outputs": [{"format": "rows", "name": "tableWithOpenTreeNames", "type": "table"}, {"format": "text", "name": "debugstring", "type": "string"}], "script": "#\n# input: originalTable\n# input: ottIdTable\n#\n\n# allowed name field columns\nallowedSpeciesColumnNames = ['species','name','Species','x','scientific name','Scientific Name']\n\n# get variables pointing to the original table that contains all trait columns \ninfields = originalTable['fields']\ninrows = originalTable['rows']\n# get a pointer to the 3 column name lookup table (with original name, ottName, ottId fields)\nottrows = ottIdTable['rows']\n\n# find a matching column for the species names.  We have to be indirect because the column could have several\n# headings.  Find a match and then return the index of the match\n\ndef findMatchingOttTableRow(originalName):\n    global ottrows,inrows\n    matched = False\n    index = -1\n    for rownum in range(len(ottrows)):\n        for attrib in ottrows[rownum]:\n            if attrib in allowedSpeciesColumnNames:\n                if (ottrows[rownum][attrib]).lower() == originalName.lower():\n                    index = rownum\n                    break\n    return index\n    \noutrows = []\ndebugstring = ''\n\ndef findIndexOfNameInFields(fields):\n    global allowedSpeciesColumnNames\n    index = 0\n    for field in fields:\n        if field in allowedSpeciesColumnNames:\n            break\n        index += 1\n    return index\n    \n\n# go through the table a row at a time, since there might be less rows in the ottTable, lets use it as the index\nfor rownum in range(len(inrows)):\n    outrow = {}\n    matched = False\n    # look at each column in the table\n    for field in inrows[rownum]:\n        # if this is the name column, replace the orignal name with a name of the form ottGenus_ottSpecies_ott<ottId>\n        if field in allowedSpeciesColumnNames:\n            ottIndex = findMatchingOttTableRow(inrows[rownum][field])\n            if ottIndex >= 0:\n                debugstring += 'name:'+inrows[rownum][field]+' matched to index '+str(ottIndex)+'\\n'\n                newname = (ottrows[ottIndex]['ottName']).replace(\" \",\"_\")+\"_ott\"+str(ottrows[ottIndex]['ottId'])\n                outrow[field] = newname\n                matched = True\n        else:\n            # if not the name field, copy data through and preserve name\n            outrow[field] = inrows[rownum][field]\n    # finished processing all fields, so add this output row, but only if it matched the ottTable\n    if matched == True:\n        outrows.append(outrow)\n        \n# create the output column list\noutcolumns = []\nfor attrib in outrows[0]:\n    outcolumns.append(attrib)\n    \n# now reorder the field list so the species names are in the front\nspeciesIndex = findIndexOfNameInFields(outcolumns)\nif speciesIndex != 0:\n    #switch the names with the current first attribute to put species names first\n    tempSaveAttribute = outcolumns[0]\n    currentSpeciesColumnName = outcolumns[speciesIndex]\n    outcolumns[0] = currentSpeciesColumnName\n    outcolumns[speciesIndex] = tempSaveAttribute\n\n    \ntableWithOpenTreeNames = {\n    'fields': outcolumns,\n    'rows': outrows}\n    \n    "}, "visualization": false, "x": 895, "y": 472}, {"girderId": "58a659fb54cdbf04513b9f4c", "modified": "2017-02-17T02:03:39.556000+00:00", "name": "Create Tree with Image LInks for PhyloPen v2", "task": {"description": "", "inputs": [{"description": "tree to add characters and images to", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}, {"description": "character matrix to add to tree tips", "format": "rows", "id": "matrix", "name": "matrix", "type": "table"}, {"description": "2 column table (taxon, imageURL) for adding image references to taxa", "format": "rows", "id": "image_reference_table", "name": "image_reference_table", "type": "table"}], "mode": "python", "name": "Create Tree with Image LInks for PhyloPen v2", "outputs": [{"description": "tree with trait and image reference data in the named nodes", "format": "nested", "id": "tree_with_traits", "name": "tree_with_traits", "type": "tree"}], "script": "#\n# Take a tree, matrix, and an image reference table as input. Create a nested format\n# tree with image references and attributes attached to the leaves of the tree for display\n# \n# KnowledgeVis, LLC\n# C Lisle\n#\n# update history\n# 2/22/16 - modified for multiple images option per taxon, with text\n\n# inputs:\n# tree - nested format tree with tipnames that match the matrix names\n# matrix - character matrix with names that match the tree tips\n# image_reference_table - 2 column table with tipname and image URL to load the image from\n\n# look through the rows of the image cross reference table.  This format comes from the phenoscape team\n# and has been processed by a previous method to look up the girder item numbers\ndef returnMatchingImageRecord(name):\n    global image_reference_table\n    record = {}\n    for row in image_reference_table['rows']:\n        #print 'looking for ',name,' in ',row\n        if (('taxon' in row) and (name == row['taxon'])):\n            return row['url']\n        if (('species' in row) and (name == row['species'])):\n            return row['url']\n        if (('name' in row) and (name == row['name'])):\n            return row['url']\n    return record\n          \n\n# look through the image matching table.  Three options for taxon name are supported because\n# matrices may not always be indexed the same.  We allow name,species, or taxon:\ndef returnMatchingImageRecordList(name):\n    global image_reference_table\n    records = []\n    for row in image_reference_table['rows']:\n        #print 'looking for ',name,' in ',row\n        if (('taxon' in row) and (name == row['taxon'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['taxon']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n        if (('species' in row) and (name == row['species'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['species']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n        if (('name' in row) and (name == row['name'])):\n            # if we found a name match, but no image was resolved, don't add this option\n            if len(row['url'])>0:\n                newrecord = {'image': row['url'], 'text': row['name']}\n                if 'character' in row:\n                    newrecord['text'] += '/character='+ str(row['character'])\n                if 'state' in row:\n                    newrecord['text'] += '/state='+ str(row['state'])\n                records.append(newrecord)\n    return records\n                        \n# look through the rows of the matrix and return a matching entry.  Return the \n# URL record or an empty set (to avoid run-time errors if data doesn't match\n\ndef returnMatchingMatrixRecord(name):\n    global matrix\n    record = {}\n    for row in matrix['rows']:\n        print 'looking for ',name,' in matrix ',row\n        if (('name' in row) and (name == row['name'])):\n            return row\n        if (('species' in row) and (name == row['species'])):\n            return row\n        if (('taxa' in row) and (name == row['taxa'])):\n            print 'found taxon match'\n            return row\n    return record\n            \n    \n# traverse through the tree and add records to the tips from the matrix and the image table\n\ndef addRecordsToTreeTips(treenode):\n    if 'children' in treenode:\n        for node in treenode['children']:\n            addRecordsToTreeTips(node)\n    else:\n        # this is a tip, add matrix and image infor\n        traits = returnMatchingMatrixRecord(treenode['node_data']['node name'])\n        #print 'matching trait record:',traits\n\n        treenode['node_data']['attributes'] = []\n        # add all columns in the character matrix, unless they are the taxa name, since this is already handled in the 'node name'\n        for trait in traits.keys():\n            if trait not in ['species','name','taxa']:\n                treenode['node_data']['attributes'].append({trait: traits[trait]})\n        # add the image attribute to point to the image binary.  There might be more than one image, so \n        # make the entry always be a list. Later we might change these records to have a key tied to a character\n        # to select which image, but just a list initially\n        nodename = treenode['node_data']['node name']\n        # only add an image record if we found an image to match this taxon\n        imageURLs = returnMatchingImageRecordList(treenode['node_data']['node name'])\n        #print 'matching image record:',imageURL\n        for imageRecord in imageURLs:\n            if 'images' in treenode['node_data']:\n                treenode['node_data']['images'].append(imageRecord)\n            else:\n                treenode['node_data']['images'] = []\n                treenode['node_data']['images'].append(imageRecord)\n\n# this routine adds any matrix categories to the record on the root of the tree that specifies\n# what fields are on the nodes.  PhyloPen uses this to parse for attributes to display in the attribute list UI\n\ndef addTraitsToNodeFieldsRecord(treeroot):\n    global matrix\n    #for field in matrix['fields']:\n    #    if field not in ['species','name','taxa']:\n    #        treeroot['node_fields'].append(field)\n    # indicate an attributes record\n    treeroot['node_fields'].append('attributes')\n    # indicate there could be an images record as well\n    treeroot['node_fields'].append('images')\n\n# ---- top level -----\n\ntree_with_traits = tree\naddRecordsToTreeTips(tree_with_traits)\naddTraitsToNodeFieldsRecord(tree_with_traits)\n\n\n\n"}, "visualization": false, "x": 1287, "y": 358}, {"girderId": "58e91b9954cdbf7bfe6bea90", "modified": "2017-04-08T17:36:49.288000+00:00", "name": "Convert OpenTree Tip Names to Scientific Names", "task": {"description": "", "inputs": [{"default": {"data": "Tree that has tip names of the form genus_species_ottID", "format": "text", "type": "string"}, "description": "tree with open tree names", "format": "nested", "id": "tree", "name": "tree with Open Tree format names", "type": "tree"}], "mode": "python", "name": "Convert OpenTree Tip Names to Scientific Names", "outputs": [{"format": "nested", "id": "tree_scientific_names", "name": "tree with scientific tip names", "type": "tree"}], "script": "# Convert OpenTree Tip Names to Scientific Names\n#\n# C. Lisle\n# KnowledgeVis, LLC\n# \n# released under Apache 2.0 open-source license\n#\n# This analysis is an algorithm to traverse a tree and rename tips from openTree format (genus_species_ottID) to \"genus species\"\n\n# inputs:\n# tree - a tree (nested format) with shortened names on the tips.  Names are the prefix (up to 9 chars) of the genus name\n\n# output:\n# tree_scientific_names - tree (in nested format) with modified names that match the matrix\n\n# setup global values\ndebugOutput = ''\nnodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \n\n\n\n# convert names from genus_species_ottid to \"genus species\"\ndef fixOpenTreeName(tipname):\n    nameTokens = tipname.split('_')\n    if len(nameTokens)>2:\n        newName = ' '.join(nameTokens[0:2])\n    else:\n        # handle special case where there was no species name, don't splice in an ottID\n        newName = nameTokens[0]\n    return newName\n\n# this is an operation to perform on a taxon node to replace its name.  It is called for each taxon of the tree\ndef taxonOperation(node):\n    # only replace names if they exist.  test first so routine doesn't cause a runtime exception if a name is missing\n    if ('node name' in node['node_data'].keys()):\n        originalName = node['node_data']['node name']\n        newName = fixOpenTreeName(originalName)\n        node['node_data']['node name'] = newName\n\n    \n\n# utility routine to recursively traverse through a phylo tree in nested format.  This traversal starts at the top and recursively traverses the tree.\n# once it finds a taxon, then the routine 'taxonOperation' is called with the taxon node as an argument.  \n\ndef treeTraversal(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            treeTraversal(node)\n    else:\n        #case for a taxa. Run a previously-defined operation on the taxon node\n        taxonOperation(treenode)    \n\n# Top Level Operations \n\n#  setup the structures and go through the tree nodes and replace any names with full names from the reference name list.  The traversal replaces names\n# in place, so when the traversal is done the tree has new node names\n\n\ntreeTraversal(tree)\nassignEdgeWeightsIfMissing(tree)\ntree_scientific_names = tree"}, "visualization": false, "x": 1485, "y": 186}]}