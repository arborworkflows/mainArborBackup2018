{"connections": [{"input": "tree", "input_step": "Convert OpenTree Tip Names to Scientific Names", "output": "outtree", "output_step": "Assign Tree Branch Branch Lengths If Missing"}, {"input": "tree", "input_step": "Assign Tree Branch Branch Lengths If Missing", "name": "tree"}, {"name": "tree with scientific tip names", "output": "tree_scientific_names", "output_step": "Convert OpenTree Tip Names to Scientific Names"}, {"input": "tree", "input_step": "Tip Names from Nested Tree", "output": "tree_scientific_names", "output_step": "Convert OpenTree Tip Names to Scientific Names"}, {"name": "nametable", "output": "nametable", "output_step": "Tip Names from Nested Tree"}], "description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree", "x": 21, "y": 161}], "mode": "workflow", "name": "WF Adopt OTL tree for PhyloPen", "outputs": [{"format": "nested", "id": "tree with scientific tip names", "name": "tree with scientific tip names", "type": "tree", "x": 818, "y": 138}, {"description": "single column table with species names", "format": "rows", "id": "nametable", "name": "nametable", "type": "table", "x": 1165, "y": 360}], "steps": [{"girderId": "590b4b1e54cdbf7a5dff8634", "modified": "2017-05-04T15:39:11.050000+00:00", "name": "Assign Tree Branch Branch Lengths If Missing", "task": {"description": "", "inputs": [{"description": "tree which may or may not have edge weights assigned", "format": "nested", "id": "tree", "name": "tree", "type": "tree"}], "mode": "python", "name": "Assign Tree Branch Branch Lengths If Missing", "outputs": [{"description": "Tree with edge weights assigned to 1.0 if they were misssing.  Existing edge weights are preserved", "format": "nested", "id": "outtree", "name": "outtree", "type": "tree"}], "script": "nodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \nouttree = tree\nassignEdgeWeightsIfMissing(outtree)\n"}, "visualization": false, "x": 249, "y": 278}, {"girderId": "58e91b9954cdbf7bfe6bea90", "modified": "2017-04-08T17:36:49.288000+00:00", "name": "Convert OpenTree Tip Names to Scientific Names", "task": {"description": "", "inputs": [{"default": {"data": "Tree that has tip names of the form genus_species_ottID", "format": "text", "type": "string"}, "description": "tree with open tree names", "format": "nested", "id": "tree", "name": "tree with Open Tree format names", "type": "tree"}], "mode": "python", "name": "Convert OpenTree Tip Names to Scientific Names", "outputs": [{"format": "nested", "id": "tree_scientific_names", "name": "tree with scientific tip names", "type": "tree"}], "script": "# Convert OpenTree Tip Names to Scientific Names\n#\n# C. Lisle\n# KnowledgeVis, LLC\n# \n# released under Apache 2.0 open-source license\n#\n# This analysis is an algorithm to traverse a tree and rename tips from openTree format (genus_species_ottID) to \"genus species\"\n\n# inputs:\n# tree - a tree (nested format) with shortened names on the tips.  Names are the prefix (up to 9 chars) of the genus name\n\n# output:\n# tree_scientific_names - tree (in nested format) with modified names that match the matrix\n\n# setup global values\ndebugOutput = ''\nnodecount = 0\n\ndef assignEdgeWeightsIfMissing(treenode):\n    global nodecount\n    treenode['node_data']['nodeid'] = nodecount\n    if ('edge_data' not in treenode):\n        treenode['edge_data'] = {}\n    if not ('weight' in treenode['edge_data']):\n        treenode['edge_data']['weight'] = 1.0\n    elif treenode['edge_data']['weight'] < 0.001:\n        treenode['edge_data']['weight'] = 1.0     \n    nodecount += 1\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            assignEdgeWeightsIfMissing(node)\n    \n\n\n\n# convert names from genus_species_ottid to \"genus species\"\ndef fixOpenTreeName(tipname):\n    nameTokens = tipname.split('_')\n    if len(nameTokens)>2:\n        newName = ' '.join(nameTokens[0:2])\n    else:\n        # handle special case where there was no species name, don't splice in an ottID\n        newName = nameTokens[0]\n    return newName\n\n# this is an operation to perform on a taxon node to replace its name.  It is called for each taxon of the tree\ndef taxonOperation(node):\n    # only replace names if they exist.  test first so routine doesn't cause a runtime exception if a name is missing\n    if ('node name' in node['node_data'].keys()):\n        originalName = node['node_data']['node name']\n        newName = fixOpenTreeName(originalName)\n        node['node_data']['node name'] = newName\n\n    \n\n# utility routine to recursively traverse through a phylo tree in nested format.  This traversal starts at the top and recursively traverses the tree.\n# once it finds a taxon, then the routine 'taxonOperation' is called with the taxon node as an argument.  \n\ndef treeTraversal(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            treeTraversal(node)\n    else:\n        #case for a taxa. Run a previously-defined operation on the taxon node\n        taxonOperation(treenode)    \n\n# Top Level Operations \n\n#  setup the structures and go through the tree nodes and replace any names with full names from the reference name list.  The traversal replaces names\n# in place, so when the traversal is done the tree has new node names\n\n\ntreeTraversal(tree)\nassignEdgeWeightsIfMissing(tree)\ntree_scientific_names = tree"}, "visualization": false, "x": 529, "y": 217}, {"girderId": "58fd208c54cdbf552d799306", "modified": "2017-04-23T21:45:48.367000+00:00", "name": "Tip Names from Nested Tree", "task": {"description": "", "inputs": [{"description": "nested format tree to extract node names from", "format": "nested", "name": "tree", "type": "tree"}], "mode": "python", "name": "Tip Names from Nested Tree", "outputs": [{"description": "single column table with species names", "format": "rows", "name": "nametable", "type": "table"}], "script": "\n# traverse a tree in nested format and output a single column table with species names from the tree taxa\n\n# C. Lisle\n# KnowledgeVis, LLC\n\n# released under the Apache 2.0 open-source license\n\n# inputs:\n#    tree - tree in nested format \n# outputs:\n#    nametable - table:rows with single column containing species names from the tree taxa\n\nnameList = []\n\n# this is invoked for each taxon node in the tree.  If the taxon is named, the name is added to a global list\ndef taxonOperation(node):\n    if 'node name' in node['node_data'].keys():\n        nameList.append(node['node_data']['node name'])\n\n        \n# recursive traversal of tree in nested format.  Once a taxon is reached, invoke the 'taxonOperation()' routine with the taxon node\ndef traverseNestedTree(treenode):\n    # look at the current tree node and see if there are children or not\n    if 'children' in treenode.keys():\n        #case for a hierarchy node, traverse to all the children\n        for node in treenode['children']:\n            traverseNestedTree(node)\n    else:\n        #case for a taxa. Look through the occurrence and add records to \n        # this node\n        taxonOperation(treenode)\n        \n# run the traversal and copy the output name list\ntraverseNestedTree(tree)\n\n# prepare the output single column table of species names\nnametable = {}\nnametable['fields'] = []\nnametable['rows'] = []\nnametable['fields'].append('name')\n\nfor name in nameList:\n    outRecord = {}\n    outRecord['name'] = name\n    nametable['rows'].append(outRecord)\n    \n\n"}, "visualization": false, "x": 837, "y": 367}]}